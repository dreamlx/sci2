# 服务单元测试实现

## 任务描述

实现 SCI2 工单系统各个服务的单元测试，包括导入服务、工单处理服务、费用明细验证服务和工单状态变更服务的测试。这些测试将确保服务层的正确性和可靠性，为后续的开发和重构提供保障。

## 输入和依赖

- 服务层实现
- 基础模型实现
- RSpec 测试框架
- FactoryBot 工厂
- 测试策略文档 (`docs/refactoring/06_testing_strategy.md`)

## 期望输出

完整的服务单元测试实现，包括：
- 导入服务测试
- 工单处理服务测试
- 费用明细验证服务测试
- 工单状态变更服务测试

## 详细实现步骤

### 1. 测试准备

确保 RSpec 和 FactoryBot 已正确配置，并创建必要的测试辅助方法：

```ruby
# spec/support/service_test_helpers.rb
module ServiceTestHelpers
  def create_admin_user
    @admin_user ||= create(:admin_user)
  end
  
  def create_test_file(content, format = :xlsx)
    file = Tempfile.new(['test', ".#{format}"])
    file.write(content)
    file.rewind
    
    uploaded_file = Rack::Test::UploadedFile.new(file.path, "application/#{format}")
    
    # 确保测试结束后删除临时文件
    ObjectSpace.define_finalizer(self, -> { file.close; file.unlink })
    
    uploaded_file
  end
end

RSpec.configure do |config|
  config.include ServiceTestHelpers, type: :service
end
```

### 2. 实现报销单导入服务测试

创建 `spec/services/reimbursement_import_service_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe ReimbursementImportService, type: :service do
  let(:admin_user) { create(:admin_user) }
  let(:file) { create_test_file("测试数据") }
  let(:service) { ReimbursementImportService.new(file, admin_user) }
  
  describe "#import" do
    context "当文件不存在时" do
      it "返回错误" do
        service = ReimbursementImportService.new(nil, admin_user)
        result = service.import
        
        expect(result[:success]).to be_falsey
        expect(result[:errors]).to include("文件不存在")
      end
    end
    
    context "当文件存在时" do
      before do
        # 模拟 Roo::Spreadsheet 的行为
        allow(Roo::Spreadsheet).to receive(:open).and_return(double(
          sheet: double(
            row: ["报销单单号", "单据名称", "报销单申请人"],
            each_row_as_hash: yield_self do |&block|
              block.call({
                "报销单单号" => "R20250101001",
                "单据名称" => "测试报销单",
                "报销单申请人" => "张三",
                "报销单申请人工号" => "EMP001",
                "申请人公司" => "测试公司",
                "申请人部门" => "测试部门",
                "报销金额（单据币种）" => 1000.00,
                "收单状态" => "已收单",
                "报销单状态" => "已付款",
                "收单日期" => "2025-01-01",
                "提交报销日期" => "2025-01-01",
                "单据标签" => ""
              })
            end
          )
        ))
      end
      
      it "导入报销单" do
        expect { service.import }.to change(Reimbursement, :count).by(1)
        
        reimbursement = Reimbursement.last
        expect(reimbursement.invoice_number).to eq("R20250101001")
        expect(reimbursement.document_name).to eq("测试报销单")
        expect(reimbursement.applicant).to eq("张三")
      end
      
      it "为非电子发票报销单创建审核工单" do
        expect { service.import }.to change(AuditWorkOrder, :count).by(1)
      end
    end
  end
end
```

### 3. 实现快递收单导入服务测试

创建 `spec/services/express_receipt_import_service_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe ExpressReceiptImportService, type: :service do
  let(:admin_user) { create(:admin_user) }
  let(:file) { create_test_file("测试数据") }
  let(:service) { ExpressReceiptImportService.new(file, admin_user) }
  let!(:reimbursement) { create(:reimbursement, invoice_number: "R20250101001") }
  
  describe "#import" do
    context "当文件存在且报销单存在时" do
      before do
        # 模拟 Roo::Spreadsheet 的行为
        allow(Roo::Spreadsheet).to receive(:open).and_return(double(
          sheet: double(
            row: ["单号", "操作时间", "操作人", "操作意见"],
            each_row_as_hash: yield_self do |&block|
              block.call({
                "单号" => "R20250101001",
                "操作时间" => "2025-01-01 10:00:00",
                "操作人" => "张三",
                "操作意见" => "快递单号: SF1234567890"
              })
            end
          )
        ))
      end
      
      it "导入快递收单记录并创建工单" do
        expect { service.import }.to change(ExpressReceipt, :count).by(1)
                                 .and change(ExpressReceiptWorkOrder, :count).by(1)
        
        express_receipt = ExpressReceipt.last
        expect(express_receipt.document_number).to eq("R20250101001")
        expect(express_receipt.tracking_number).to eq("SF1234567890")
        
        work_order = ExpressReceiptWorkOrder.last
        expect(work_order.reimbursement_id).to eq(reimbursement.id)
        expect(work_order.tracking_number).to eq("SF1234567890")
        expect(work_order.status).to eq("received")
      end
      
      it "更新报销单收单状态" do
        service.import
        
        reimbursement.reload
        expect(reimbursement.receipt_status).to eq("received")
        expect(reimbursement.receipt_date).to be_present
      end
    end
    
    context "当报销单不存在时" do
      before do
        # 模拟 Roo::Spreadsheet 的行为
        allow(Roo::Spreadsheet).to receive(:open).and_return(double(
          sheet: double(
            row: ["单号", "操作时间", "操作人", "操作意见"],
            each_row_as_hash: yield_self do |&block|
              block.call({
                "单号" => "R20250101999", # 不存在的报销单
                "操作时间" => "2025-01-01 10:00:00",
                "操作人" => "张三",
                "操作意见" => "快递单号: SF1234567890"
              })
            end
          )
        ))
      end
      
      it "记录未匹配的快递单" do
        result = service.import
        
        expect(result[:success]).to be_truthy
        expect(result[:matched]).to eq(0)
        expect(result[:unmatched]).to eq(1)
        expect(result[:unmatched_receipts].first[:document_number]).to eq("R20250101999")
        expect(result[:unmatched_receipts].first[:error]).to eq("报销单不存在")
      end
    end
  end
  
  describe "#manual_match" do
    let(:unmatched_tracking_number) { "SF1234567890" }
    
    before do
      service.instance_variable_set(:@unmatched_receipts, [{
        original_data: { "操作时间" => "2025-01-01 10:00:00", "操作人" => "张三" },
        document_number: "R20250101999",
        tracking_number: unmatched_tracking_number,
        error: "报销单不存在"
      }])
    end
    
    it "手动匹配未匹配的快递单" do
      expect {
        service.manual_match(unmatched_tracking_number, reimbursement.id)
      }.to change(ExpressReceipt, :count).by(1)
         .and change(ExpressReceiptWorkOrder, :count).by(1)
    end
  end
end
```

### 4. 实现审核工单处理服务测试

创建 `spec/services/audit_work_order_service_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe AuditWorkOrderService, type: :service do
  let(:admin_user) { create(:admin_user) }
  let(:reimbursement) { create(:reimbursement) }
  let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement, status: 'pending') }
  let(:service) { AuditWorkOrderService.new(audit_work_order, admin_user) }
  
  describe "#start_processing" do
    it "将工单状态从 pending 转换为 processing" do
      service.start_processing
      expect(audit_work_order.reload.status).to eq('processing')
    end
  end
  
  describe "#approve" do
    before { audit_work_order.update(status: 'auditing') }
    
    it "将工单状态从 auditing 转换为 approved" do
      service.approve("审核通过")
      
      audit_work_order.reload
      expect(audit_work_order.status).to eq('approved')
      expect(audit_work_order.audit_result).to eq('approved')
      expect(audit_work_order.audit_comment).to eq('审核通过')
      expect(audit_work_order.audit_date).to be_present
    end
    
    it "更新关联的费用明细状态为已验证" do
      fee_detail = create(:fee_detail, document_number: reimbursement.invoice_number, verification_status: 'pending')
      audit_work_order.select_fee_detail(fee_detail)
      
      service.approve
      
      expect(fee_detail.reload.verification_status).to eq('verified')
    end
  end
  
  describe "#reject" do
    before { audit_work_order.update(status: 'auditing') }
    
    it "将工单状态从 auditing 转换为 rejected" do
      service.reject("审核拒绝")
      
      audit_work_order.reload
      expect(audit_work_order.status).to eq('rejected')
      expect(audit_work_order.audit_result).to eq('rejected')
      expect(audit_work_order.audit_comment).to eq('审核拒绝')
      expect(audit_work_order.audit_date).to be_present
    end
  end
  
  describe "#create_communication_work_order" do
    before { audit_work_order.update(status: 'auditing') }
    
    it "创建沟通工单并更新审核工单状态" do
      expect {
        service.create_communication_work_order(
          communication_method: 'email',
          initiator_role: 'auditor',
          content: '需要沟通'
        )
      }.to change(CommunicationWorkOrder, :count).by(1)
         .and change(CommunicationRecord, :count).by(1)
      
      expect(audit_work_order.reload.status).to eq('needs_communication')
    end
    
    it "关联费用明细并标记为有问题" do
      fee_detail = create(:fee_detail, document_number: reimbursement.invoice_number, verification_status: 'pending')
      
      service.create_communication_work_order(
        communication_method: 'email',
        initiator_role: 'auditor',
        content: '需要沟通',
        fee_detail_ids: [fee_detail.id]
      )
      
      expect(fee_detail.reload.verification_status).to eq('problematic')
    end
  end
  
  describe "#verify_fee_detail" do
    let(:fee_detail) { create(:fee_detail, document_number: reimbursement.invoice_number, verification_status: 'pending') }
    let(:verification_service) { instance_double(FeeDetailVerificationService) }
    
    before do
      allow(FeeDetailVerificationService).to receive(:new).with(admin_user).and_return(verification_service)
      allow(FeeDetail).to receive(:find).with(fee_detail.id).and_return(fee_detail)
    end
    
    it "调用 FeeDetailVerificationService 更新验证状态" do
      expect(verification_service).to receive(:update_verification_status).with(fee_detail, 'verified', '验证通过')
      
      service.verify_fee_detail(fee_detail.id, 'verified', '验证通过')
    end
  end
end
```

### 5. 实现沟通工单处理服务测试

创建 `spec/services/communication_work_order_service_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe CommunicationWorkOrderService, type: :service do
  let(:admin_user) { create(:admin_user) }
  let(:reimbursement) { create(:reimbursement) }
  let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement, status: 'needs_communication') }
  let(:communication_work_order) { create(:communication_work_order, reimbursement: reimbursement, audit_work_order: audit_work_order, status: 'open') }
  let(:service) { CommunicationWorkOrderService.new(communication_work_order, admin_user) }
  
  describe "#start_communication" do
    it "将工单状态从 open 转换为 in_progress" do
      service.start_communication
      expect(communication_work_order.reload.status).to eq('in_progress')
    end
  end
  
  describe "#resolve" do
    before { communication_work_order.update(status: 'in_progress') }
    
    it "将工单状态从 in_progress 转换为 resolved 并通知父工单" do
      service.resolve("问题已解决")
      
      communication_work_order.reload
      expect(communication_work_order.status).to eq('resolved')
      expect(communication_work_order.resolution_summary).to eq("问题已解决")
      expect(audit_work_order.reload.status).to eq('auditing')
    end
  end
  
  describe "#add_communication_record" do
    it "添加沟通记录" do
      expect {
        service.add_communication_record(
          content: '测试沟通内容',
          communicator_role: 'auditor',
          communication_method: 'email'
        )
      }.to change(CommunicationRecord, :count).by(1)
    end
  end
  
  describe "#resolve_fee_detail_issue" do
    let(:fee_detail) { create(:fee_detail, document_number: reimbursement.invoice_number, verification_status: 'problematic') }
    let!(:selection) { create(:fee_detail_selection, communication_work_order: communication_work_order, fee_detail: fee_detail, verification_status: 'problematic') }
    
    it "更新费用明细选择记录的验证意见但不更新费用明细状态" do
      service.resolve_fee_detail_issue(fee_detail.id, '问题已解决')
      
      selection.reload
      expect(selection.verification_comment).to eq('问题已解决')
      expect(fee_detail.reload.verification_status).to eq('problematic')
    end
  end
end
```

### 6. 实现快递收单工单处理服务测试

创建 `spec/services/express_receipt_work_order_service_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe ExpressReceiptWorkOrderService, type: :service do
  let(:admin_user) { create(:admin_user) }
  let(:reimbursement) { create(:reimbursement) }
  let(:express_receipt_work_order) { create(:express_receipt_work_order, reimbursement: reimbursement, status: 'received') }
  let(:service) { ExpressReceiptWorkOrderService.new(express_receipt_work_order, admin_user) }
  
  describe "#process" do
    it "将工单状态从 received 转换为 processed" do
      service.process
      expect(express_receipt_work_order.reload.status).to eq('processed')
    end
  end
  
  describe "#complete" do
    before { express_receipt_work_order.update(status: 'processed') }
    
    it "将工单状态从 processed 转换为 completed 并创建审核工单" do
      expect { service.complete }.to change(AuditWorkOrder, :count).by(1)
      
      expect(express_receipt_work_order.reload.status).to eq('completed')
      
      audit_work_order = AuditWorkOrder.last
      expect(audit_work_order.reimbursement_id).to eq(reimbursement.id)
      expect(audit_work_order.express_receipt_work_order_id).to eq(express_receipt_work_order.id)
      expect(audit_work_order.status).to eq('pending')
    end
    
    it "关联费用明细到审核工单" do
      fee_detail = create(:fee_detail, document_number: reimbursement.invoice_number)
      
      expect { service.complete }.to change(FeeDetailSelection, :count).by(1)
      
      audit_work_order = AuditWorkOrder.last
      expect(audit_work_order.fee_details).to include(fee_detail)
    end
  end
end
```

### 7. 实现费用明细验证服务测试

创建 `spec/services/fee_detail_verification_service_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe FeeDetailVerificationService, type: :service do
  let(:admin_user) { create(:admin_user) }
  let(:service) { FeeDetailVerificationService.new(admin_user) }
  
  describe "#verify_fee_details" do
    let!(:fee_detail1) { create(:fee_detail, verification_status: 'pending') }
    let!(:fee_detail2) { create(:fee_detail, verification_status: 'pending') }
    
    it "批量更新费用明细的验证状态" do
      result = service.verify_fee_details([fee_detail1.id, fee_detail2.id], 'verified', '批量验证')
      
      expect(result[:success]).to eq(2)
      expect(result[:failure]).to eq(0)
      
      expect(fee_detail1.reload.verification_status).to eq('verified')
      expect(fee_detail2.reload.verification_status).to eq('verified')
    end
  end
  
  describe "#update_verification_status" do
    let(:fee_detail) { create(:fee_detail, verification_status: 'pending') }
    let(:reimbursement) { create(:reimbursement, is_complete: false) }
    let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement) }
    let!(:selection) { create(:fee_detail_selection, audit_work_order: audit_work_order, fee_detail: fee_detail) }
    
    before do
      fee_detail.update(document_number: reimbursement.invoice_number)
    end
    
    it "更新费用明细的验证状态" do
      service.update_verification_status(fee_detail, 'verified', '验证通过')
      
      expect(fee_detail.reload.verification_status).to eq('verified')
    end
    
    it "更新所有关联的费用明细选择记录" do
      service.update_verification_status(fee_detail, 'verified', '验证通过')
      
      selection.reload
      expect(selection.verification_status).to eq('verified')
      expect(selection.verification_comment).to eq('验证通过')
      expect(selection.verified_by).to eq(admin_user.id)
      expect(selection.verified_at).to be_present
    end
    
    it "如果报销单已关闭，不允许更新" do
      reimbursement.update(is_complete: true)
      
      result = service.update_verification_status(fee_detail, 'verified', '验证通过')
      
      expect(result).to be_falsey
      expect(fee_detail.errors[:base]).to include("关联报销单已关闭，无法修改费用明细状态")
      expect(fee_detail.reload.verification_status).to eq('pending')
    end
  end
end
```

### 8. 实现工单状态变更服务测试

创建 `spec/services/work_order_status_change_service_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe WorkOrderStatusChangeService, type: :service do
  let(:admin_user) { create(:admin_user) }
  let(:service) { WorkOrderStatusChangeService.new(admin_user) }
  
  describe "#record_status_change" do
    let(:express_receipt_work_order) { create(:express_receipt_work_order) }
    let(:audit_work_order) { create(:audit_work_order) }
    let(:communication_work_order) { create(:communication_work_order) }
    
    it "记录快递收单工单的状态变更" do
      expect {
        service.record_status_change(express_receipt_work_order, 'received', 'processed', '处理完成')
      }.to change(WorkOrderStatusChange, :count).by(1)
      
      status_change = WorkOrderStatusChange.last
      expect(status_change.work_order_type).to eq('express_receipt')
      expect(status_change.work_order_id).to eq(express_receipt_work_order.id)
      expect(status_change.from_status).to eq('received')
      expect(status_change.to_status).to eq('processed')
      expect(status_change.changed_by).to eq(admin_user.id)
      expect(status_change.reason).to eq('处理完成')
    end
    
    it "记录审核工单的状态变更" do
      expect {
        service.record_status_change(audit_work_order, 'pending', 'processing')
      }.to change(WorkOrderStatusChange, :count).by(1)
      
      status_change = WorkOrderStatusChange.last
      expect(status_change.work_order_type).to eq('audit')
      expect(status_change.work_order_id).to eq(audit_work_order.id)
    end
    
    it "记录沟通工单的状态变更" do
      expect {
        service.record_status_change(communication_work_order, 'open', 'in_progress')
      }.to change(WorkOrderStatusChange, :count).by(1)
      
      status_change = WorkOrderStatusChange.last
      expect(status_change.work_order_type).to eq('communication')
      expect(status_change.work_order_id).to eq(communication_work_order.id)
    end
    
    it "对于未知的工单类型抛出异常" do
      expect {
        service.record_status_change(Object.new, 'old', 'new')
      }.to raise_error(ArgumentError, /未知的工单类型/)
    end
  end
  
  describe "#get_status_changes" do
    let(:express_receipt_work_order) { create(:express_receipt_work_order) }
    let!(:status_change1) { create(:work_order_status_change, work_order_type: 'express_receipt', work_order_id: express_receipt_work_order.id, changed_at: 2.days.ago) }
    let!(:status_change2) { create(:work_order_status_change, work_order_type: 'express_receipt', work_order_id: express_receipt_work_order.id, changed_at: 1.day.ago) }
    
    it "获取工单的状态变更历史，按时间倒序排列" do
      changes = service.get_status_changes(express_receipt_work_order)
      
      expect(changes.count).to eq(2)
      expect(changes.first).to eq(status_change2)
      expect(changes.last).to eq(status_change1)
    end
  end
end
```

## 测试验证方法

1. 运行所有服务测试：`bundle exec rspec spec/services`
2. 运行特定服务测试：`bundle exec rspec spec/services/reimbursement_import_service_spec.rb`
3. 运行特定测试用例：`bundle exec rspec spec/services/reimbursement_import_service_spec.rb:10`

## 注意事项

1. 确保测试覆盖所有服务的关键功能
2. 使用 mock 和 stub 隔离依赖，特别是外部服务和文件操作
3. 特别关注导入服务的测试，确保正确处理各种边缘情况
4. 特别关注工单处理服务的测试，确保状态转换和关联操作正确
5. 特别关注费用明细验证服务的测试，确保沟通工单解决后状态不自动更新
6. 使用 FactoryBot 创建测试数据，避免在测试中直接创建对象
7. 使用 DatabaseCleaner 确保测试之间的数据隔离
8. 考虑使用 SimpleCov 监控测试覆盖率