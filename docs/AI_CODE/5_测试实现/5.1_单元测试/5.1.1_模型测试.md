# 模型单元测试实现

## 任务描述

实现 SCI2 工单系统各个模型的单元测试，包括验证、关联关系、方法和状态机功能的测试。这些测试将确保模型的正确性和可靠性，为后续的开发和重构提供保障。

## 输入和依赖

- 基础模型实现
- RSpec 测试框架
- FactoryBot 工厂
- 测试策略文档 (`docs/refactoring/06_testing_strategy.md`)

## 期望输出

完整的模型单元测试实现，包括：
- 报销单模型测试
- 快递收单工单模型测试
- 审核工单模型测试
- 沟通工单模型测试
- 费用明细模型测试
- 关联模型测试

## 详细实现步骤

### 1. 设置 RSpec 和 FactoryBot

确保 RSpec 和 FactoryBot 已正确配置：

```ruby
# Gemfile
group :development, :test do
  gem 'rspec-rails'
  gem 'factory_bot_rails'
  gem 'faker'
  gem 'shoulda-matchers'
  gem 'database_cleaner-active_record'
end
```

配置 RSpec 和相关支持文件，确保测试环境正确设置。

### 2. 创建工厂

为每个模型创建工厂，以便在测试中快速创建测试数据：

```ruby
# spec/factories/reimbursements.rb
FactoryBot.define do
  factory :reimbursement do
    sequence(:invoice_number) { |n| "R#{Time.current.strftime('%Y%m%d')}#{n.to_s.rjust(3, '0')}" }
    document_name { "测试报销单" }
    applicant { "张三" }
    applicant_id { "EMP001" }
    company { "测试公司" }
    department { "测试部门" }
    amount { 1000.00 }
    receipt_status { "pending" }
    reimbursement_status { "processing" }
    is_electronic { false }
    is_complete { false }
  end
end
```

为其他模型（ExpressReceiptWorkOrder, AuditWorkOrder, CommunicationWorkOrder, FeeDetail 等）创建类似的工厂。

### 3. 实现报销单模型测试

创建 `spec/models/reimbursement_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe Reimbursement, type: :model do
  describe "验证" do
    it { should validate_presence_of(:invoice_number) }
    it { should validate_uniqueness_of(:invoice_number) }
    it { should validate_presence_of(:document_name) }
    it { should validate_presence_of(:applicant) }
    it { should validate_presence_of(:applicant_id) }
  end
  
  describe "关联关系" do
    it { should have_many(:express_receipt_work_orders).dependent(:destroy) }
    it { should have_many(:audit_work_orders).dependent(:destroy) }
    it { should have_many(:communication_work_orders).dependent(:destroy) }
    it { should have_many(:fee_details) }
  end
  
  describe "#mark_as_received" do
    let(:reimbursement) { create(:reimbursement, receipt_status: 'pending') }
    
    it "将报销单标记为已收单" do
      reimbursement.mark_as_received
      expect(reimbursement.receipt_status).to eq('received')
      expect(reimbursement.receipt_date).to be_present
    end
  end
  
  describe "#mark_as_complete" do
    let(:reimbursement) { create(:reimbursement, is_complete: false, reimbursement_status: 'processing') }
    
    it "将报销单标记为已完成" do
      reimbursement.mark_as_complete
      expect(reimbursement.is_complete).to be_truthy
      expect(reimbursement.reimbursement_status).to eq('closed')
    end
  end
end
```

### 4. 实现快递收单工单模型测试

创建 `spec/models/express_receipt_work_order_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe ExpressReceiptWorkOrder, type: :model do
  describe "验证" do
    it { should validate_presence_of(:status) }
    it { should validate_presence_of(:tracking_number) }
    it { should validate_inclusion_of(:status).in_array(%w[received processed completed]) }
  end
  
  describe "关联关系" do
    it { should belong_to(:reimbursement) }
    it { should have_one(:audit_work_order) }
    it { should have_many(:work_order_status_changes) }
  end
  
  describe "状态机" do
    let(:work_order) { create(:express_receipt_work_order, status: 'received') }
    
    it "初始状态为 received" do
      new_work_order = ExpressReceiptWorkOrder.new
      expect(new_work_order.status).to eq('received')
    end
    
    it "process 事件从 received 转换到 processed" do
      expect(work_order.process).to be_truthy
      expect(work_order.reload.status).to eq('processed')
    end
    
    it "complete 事件从 processed 转换到 completed 并创建审核工单" do
      work_order.update(status: 'processed')
      
      expect { work_order.complete }.to change(AuditWorkOrder, :count).by(1)
      expect(work_order.reload.status).to eq('completed')
      
      audit_work_order = AuditWorkOrder.last
      expect(audit_work_order.reimbursement_id).to eq(work_order.reimbursement_id)
      expect(audit_work_order.express_receipt_work_order_id).to eq(work_order.id)
      expect(audit_work_order.status).to eq('pending')
    end
  end
  
  describe "回调" do
    let(:work_order) { create(:express_receipt_work_order, status: 'received') }
    
    it "状态变更时记录状态变更历史" do
      expect { work_order.update(status: 'processed') }.to change(WorkOrderStatusChange, :count).by(1)
    end
  end
end
```

### 5. 实现审核工单模型测试

创建 `spec/models/audit_work_order_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe AuditWorkOrder, type: :model do
  describe "验证" do
    it { should validate_presence_of(:status) }
    it { should validate_inclusion_of(:status).in_array(%w[pending processing auditing approved rejected needs_communication completed]) }
  end
  
  describe "关联关系" do
    it { should belong_to(:reimbursement) }
    it { should belong_to(:express_receipt_work_order).optional }
    it { should have_many(:communication_work_orders).dependent(:nullify) }
    it { should have_many(:fee_detail_selections).dependent(:destroy) }
    it { should have_many(:fee_details).through(:fee_detail_selections) }
    it { should have_many(:work_order_status_changes) }
  end
  
  describe "状态机" do
    let(:audit_work_order) { create(:audit_work_order, status: 'pending') }
    
    it "初始状态为 pending" do
      new_work_order = AuditWorkOrder.new
      expect(new_work_order.status).to eq('pending')
    end
    
    it "start_processing 事件从 pending 转换到 processing" do
      expect(audit_work_order.start_processing).to be_truthy
      expect(audit_work_order.reload.status).to eq('processing')
    end
    
    it "start_audit 事件从 processing 转换到 auditing" do
      audit_work_order.update(status: 'processing')
      expect(audit_work_order.start_audit).to be_truthy
      expect(audit_work_order.reload.status).to eq('auditing')
    end
    
    it "approve 事件从 auditing 转换到 approved" do
      audit_work_order.update(status: 'auditing')
      expect(audit_work_order.approve).to be_truthy
      expect(audit_work_order.reload.status).to eq('approved')
      expect(audit_work_order.audit_result).to eq('approved')
      expect(audit_work_order.audit_date).to be_present
    end
    
    it "reject 事件从 auditing 或 needs_communication 转换到 rejected" do
      audit_work_order.update(status: 'auditing')
      expect(audit_work_order.reject).to be_truthy
      expect(audit_work_order.reload.status).to eq('rejected')
      expect(audit_work_order.audit_result).to eq('rejected')
      expect(audit_work_order.audit_date).to be_present
    end
  end
  
  describe "#create_communication_work_order" do
    let(:audit_work_order) { create(:audit_work_order, status: 'auditing') }
    let(:fee_detail) { create(:fee_detail, document_number: audit_work_order.reimbursement.invoice_number) }
    
    it "创建沟通工单并关联费用明细" do
      expect {
        audit_work_order.create_communication_work_order(
          communication_method: 'email',
          initiator_role: 'auditor',
          fee_detail_ids: [fee_detail.id]
        )
      }.to change(CommunicationWorkOrder, :count).by(1)
      
      comm_order = CommunicationWorkOrder.last
      expect(comm_order.reimbursement_id).to eq(audit_work_order.reimbursement_id)
      expect(comm_order.audit_work_order_id).to eq(audit_work_order.id)
      expect(comm_order.status).to eq('open')
      expect(comm_order.fee_details).to include(fee_detail)
      expect(fee_detail.reload.verification_status).to eq('problematic')
      expect(audit_work_order.reload.status).to eq('needs_communication')
    end
  end
  
  describe "#verify_fee_detail" do
    let(:audit_work_order) { create(:audit_work_order) }
    let(:fee_detail) { create(:fee_detail) }
    let!(:selection) { create(:fee_detail_selection, audit_work_order: audit_work_order, fee_detail: fee_detail) }
    
    it "更新费用明细选择记录和费用明细的验证状态" do
      audit_work_order.verify_fee_detail(fee_detail, 'verified', '验证通过')
      
      selection.reload
      expect(selection.verification_status).to eq('verified')
      expect(selection.verification_comment).to eq('验证通过')
      expect(selection.verified_by).to be_present
      expect(selection.verified_at).to be_present
      
      expect(fee_detail.reload.verification_status).to eq('verified')
    end
  end
end
```

### 6. 实现沟通工单模型测试

创建 `spec/models/communication_work_order_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe CommunicationWorkOrder, type: :model do
  describe "验证" do
    it { should validate_presence_of(:status) }
    it { should validate_inclusion_of(:status).in_array(%w[open in_progress resolved unresolved closed]) }
  end
  
  describe "关联关系" do
    it { should belong_to(:reimbursement) }
    it { should belong_to(:audit_work_order) }
    it { should have_many(:communication_records).dependent(:destroy) }
    it { should have_many(:fee_detail_selections).dependent(:destroy) }
    it { should have_many(:fee_details).through(:fee_detail_selections) }
    it { should have_many(:work_order_status_changes) }
  end
  
  describe "状态机" do
    let(:communication_work_order) { create(:communication_work_order, status: 'open') }
    let(:audit_work_order) { communication_work_order.audit_work_order }
    
    it "初始状态为 open" do
      new_work_order = CommunicationWorkOrder.new
      expect(new_work_order.status).to eq('open')
    end
    
    it "start_communication 事件从 open 转换到 in_progress" do
      expect(communication_work_order.start_communication).to be_truthy
      expect(communication_work_order.reload.status).to eq('in_progress')
    end
    
    it "resolve 事件从 in_progress 转换到 resolved 并通知父工单" do
      communication_work_order.update(status: 'in_progress')
      audit_work_order.update(status: 'needs_communication')
      
      expect(communication_work_order.resolve).to be_truthy
      expect(communication_work_order.reload.status).to eq('resolved')
      expect(audit_work_order.reload.status).to eq('auditing')
    end
  end
  
  describe "#add_communication_record" do
    let(:communication_work_order) { create(:communication_work_order) }
    
    it "创建沟通记录" do
      expect {
        communication_work_order.add_communication_record(
          content: '测试沟通内容',
          communicator_role: 'auditor',
          communicator_name: '测试人员',
          communication_method: 'email'
        )
      }.to change(CommunicationRecord, :count).by(1)
    end
  end
  
  describe "#resolve_fee_detail_issue" do
    let(:communication_work_order) { create(:communication_work_order) }
    let(:fee_detail) { create(:fee_detail) }
    let!(:selection) { create(:fee_detail_selection, communication_work_order: communication_work_order, fee_detail: fee_detail) }
    
    it "更新费用明细选择记录的验证意见" do
      communication_work_order.resolve_fee_detail_issue(fee_detail, '问题已解决')
      
      selection.reload
      expect(selection.verification_comment).to eq('问题已解决')
    end
  end
end
```

### 7. 实现费用明细模型测试

创建 `spec/models/fee_detail_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe FeeDetail, type: :model do
  describe "验证" do
    it { should validate_presence_of(:document_number) }
    it { should validate_presence_of(:fee_type) }
    it { should validate_presence_of(:amount) }
    it { should validate_presence_of(:verification_status) }
    it { should validate_numericality_of(:amount).is_greater_than(0) }
  end
  
  describe "关联关系" do
    it { should belong_to(:reimbursement).optional }
    it { should have_many(:fee_detail_selections).dependent(:destroy) }
  end
  
  describe "作用域" do
    let!(:pending_fee_detail) { create(:fee_detail, verification_status: 'pending') }
    let!(:verified_fee_detail) { create(:fee_detail, verification_status: 'verified') }
    let!(:rejected_fee_detail) { create(:fee_detail, verification_status: 'rejected') }
    let!(:problematic_fee_detail) { create(:fee_detail, verification_status: 'problematic') }
    
    it "pending 返回待验证的费用明细" do
      expect(FeeDetail.pending).to include(pending_fee_detail)
      expect(FeeDetail.pending).not_to include(verified_fee_detail, rejected_fee_detail, problematic_fee_detail)
    end
    
    it "verified 返回已验证的费用明细" do
      expect(FeeDetail.verified).to include(verified_fee_detail)
      expect(FeeDetail.verified).not_to include(pending_fee_detail, rejected_fee_detail, problematic_fee_detail)
    end
  end
  
  describe "#mark_as_verified" do
    let(:fee_detail) { create(:fee_detail, verification_status: 'pending') }
    
    it "将费用明细标记为已验证" do
      fee_detail.mark_as_verified
      expect(fee_detail.verification_status).to eq('verified')
    end
  end
  
  describe "#mark_as_problematic" do
    let(:fee_detail) { create(:fee_detail, verification_status: 'pending') }
    
    it "将费用明细标记为有问题" do
      fee_detail.mark_as_problematic
      expect(fee_detail.verification_status).to eq('problematic')
    end
  end
  
  describe "#mark_as_rejected" do
    let(:fee_detail) { create(:fee_detail, verification_status: 'pending') }
    
    it "将费用明细标记为已拒绝" do
      fee_detail.mark_as_rejected
      expect(fee_detail.verification_status).to eq('rejected')
    end
  end
end
```

### 8. 实现关联模型测试

#### 8.1 费用明细选择模型测试

创建 `spec/models/fee_detail_selection_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe FeeDetailSelection, type: :model do
  describe "验证" do
    it { should validate_uniqueness_of(:fee_detail_id).scoped_to(:audit_work_order_id).with_message(/已经存在/).allow_nil }
    it { should validate_uniqueness_of(:fee_detail_id).scoped_to(:communication_work_order_id).with_message(/已经存在/).allow_nil }
  end
  
  describe "关联关系" do
    it { should belong_to(:fee_detail) }
    it { should belong_to(:audit_work_order).optional }
    it { should belong_to(:communication_work_order).optional }
  end
  
  describe "自定义验证" do
    it "确保只关联到一个工单" do
      fee_detail = create(:fee_detail)
      audit_work_order = create(:audit_work_order)
      communication_work_order = create(:communication_work_order)
      
      # 没有关联任何工单
      selection = FeeDetailSelection.new(fee_detail: fee_detail)
      expect(selection).not_to be_valid
      expect(selection.errors[:base]).to include("必须关联到审核工单或沟通工单")
      
      # 同时关联两个工单
      selection = FeeDetailSelection.new(
        fee_detail: fee_detail,
        audit_work_order: audit_work_order,
        communication_work_order: communication_work_order
      )
      expect(selection).not_to be_valid
      expect(selection.errors[:base]).to include("不能同时关联到审核工单和沟通工单")
      
      # 只关联审核工单
      selection = FeeDetailSelection.new(
        fee_detail: fee_detail,
        audit_work_order: audit_work_order
      )
      expect(selection).to be_valid
      
      # 只关联沟通工单
      selection = FeeDetailSelection.new(
        fee_detail: fee_detail,
        communication_work_order: communication_work_order
      )
      expect(selection).to be_valid
    end
  end
end
```

#### 8.2 沟通记录模型测试

创建 `spec/models/communication_record_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe CommunicationRecord, type: :model do
  describe "验证" do
    it { should validate_presence_of(:content) }
    it { should validate_presence_of(:communicator_role) }
  end
  
  describe "关联关系" do
    it { should belong_to(:communication_work_order) }
  end
  
  describe "回调" do
    it "创建前设置 recorded_at" do
      communication_work_order = create(:communication_work_order)
      record = CommunicationRecord.create!(
        communication_work_order: communication_work_order,
        content: "测试沟通内容",
        communicator_role: "auditor"
      )
      
      expect(record.recorded_at).to be_present
    end
  end
end
```

#### 8.3 工单状态变更模型测试

创建 `spec/models/work_order_status_change_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe WorkOrderStatusChange, type: :model do
  describe "验证" do
    it { should validate_presence_of(:work_order_type) }
    it { should validate_presence_of(:work_order_id) }
    it { should validate_presence_of(:to_status) }
    it { should validate_presence_of(:changed_at) }
  end
  
  describe "作用域" do
    let!(:express_receipt_change) { create(:work_order_status_change, work_order_type: 'express_receipt') }
    let!(:audit_change) { create(:work_order_status_change, work_order_type: 'audit') }
    let!(:communication_change) { create(:work_order_status_change, work_order_type: 'communication') }
    
    it "for_express_receipt_work_orders 返回快递收单工单的状态变更" do
      expect(WorkOrderStatusChange.for_express_receipt_work_orders).to include(express_receipt_change)
      expect(WorkOrderStatusChange.for_express_receipt_work_orders).not_to include(audit_change, communication_change)
    end
    
    it "for_audit_work_orders 返回审核工单的状态变更" do
      expect(WorkOrderStatusChange.for_audit_work_orders).to include(audit_change)
      expect(WorkOrderStatusChange.for_audit_work_orders).not_to include(express_receipt_change, communication_change)
    end
    
    it "for_communication_work_orders 返回沟通工单的状态变更" do
      expect(WorkOrderStatusChange.for_communication_work_orders).to include(communication_change)
      expect(WorkOrderStatusChange.for_communication_work_orders).not_to include(express_receipt_change, audit_change)
    end
  end
  
  describe "#work_order" do
    it "返回关联的工单" do
      express_receipt_work_order = create(:express_receipt_work_order)
      status_change = create(:work_order_status_change, 
                            work_order_type: 'express_receipt', 
                            work_order_id: express_receipt_work_order.id)
      
      expect(status_change.work_order).to eq(express_receipt_work_order)
    end
  end
end
```

## 测试验证方法

1. 运行所有模型测试：`bundle exec rspec spec/models`
2. 运行特定模型测试：`bundle exec rspec spec/models/reimbursement_spec.rb`
3. 运行特定测试用例：`bundle exec rspec spec/models/reimbursement_spec.rb:10`

## 注意事项

1. 确保测试覆盖所有模型的关键功能
2. 特别关注状态机的测试，确保状态转换正确
3. 特别关注费用明细验证逻辑的测试，确保沟通工单解决后状态不自动更新
4. 特别关注工单创建逻辑的测试，确保两种审核工单创建路径正确实现
5. 使用 FactoryBot 创建测试数据，避免在测试中直接创建对象
6. 使用 Shoulda Matchers 简化验证和关联关系的测试
7. 使用 DatabaseCleaner 确保测试之间的数据隔离
8. 考虑使用 SimpleCov 监控测试覆盖率