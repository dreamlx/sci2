# 沟通工单处理服务实现

## 任务描述

实现沟通工单处理服务（CommunicationWorkOrderService），用于处理沟通工单的状态流转、沟通记录添加、费用明细问题解决等功能。该服务是工单系统的核心业务逻辑之一，负责处理审核过程中的沟通流程。

## 输入和依赖

- 已完成的报销单模型
- 已完成的审核工单模型
- 已完成的沟通工单模型
- 已完成的沟通记录模型
- 已完成的费用明细模型
- 已完成的费用明细选择模型
- 服务实现设计文档 (`docs/refactoring/04_service_implementation.md`)

## 期望输出

完整的沟通工单处理服务实现，包括：
- 工单状态流转功能
- 沟通记录添加功能
- 费用明细问题解决功能
- 通知父工单（审核工单）功能
- 错误处理和验证功能

## 详细实现步骤

### 1. 创建沟通工单处理服务

创建 `app/services/communication_work_order_service.rb` 文件：

```ruby
# app/services/communication_work_order_service.rb
class CommunicationWorkOrderService
  def initialize(communication_work_order, current_admin_user)
    @communication_work_order = communication_work_order
    @current_admin_user = current_admin_user
  end
  
  def start_communication
    @communication_work_order.start_communication
  end
  
  def resolve(resolution_summary = nil)
    result = @communication_work_order.resolve
    
    if result && resolution_summary.present?
      @communication_work_order.update(resolution_summary: resolution_summary)
    end
    
    result
  end
  
  def mark_unresolved(resolution_summary = nil)
    result = @communication_work_order.mark_unresolved
    
    if result && resolution_summary.present?
      @communication_work_order.update(resolution_summary: resolution_summary)
    end
    
    result
  end
  
  def close
    @communication_work_order.close
  end
  
  def add_communication_record(params)
    @communication_work_order.add_communication_record(
      content: params[:content],
      communicator_role: params[:communicator_role],
      communicator_name: params[:communicator_name] || @current_admin_user.email,
      communication_method: params[:communication_method] || 'system',
      recorded_at: Time.current
    )
  end
  
  def resolve_fee_detail_issue(fee_detail_id, resolution)
    fee_detail = FeeDetail.find(fee_detail_id)
    @communication_work_order.resolve_fee_detail_issue(fee_detail, resolution)
  end
  
  def select_fee_detail(fee_detail_id)
    fee_detail = FeeDetail.find(fee_detail_id)
    @communication_work_order.select_fee_detail(fee_detail)
  end
end
```

### 2. 创建沟通工单控制器

创建 `app/controllers/admin/communication_work_orders_controller.rb` 文件：

```ruby
# app/controllers/admin/communication_work_orders_controller.rb
module Admin
  class CommunicationWorkOrdersController < ApplicationController
    before_action :set_communication_work_order, except: [:index, :new, :create]
    
    def index
      @communication_work_orders = CommunicationWorkOrder.all
    end
    
    def show
      @communication_work_order = CommunicationWorkOrder.find(params[:id])
    end
    
    def new
      @communication_work_order = CommunicationWorkOrder.new
    end
    
    def create
      @communication_work_order = CommunicationWorkOrder.new(communication_work_order_params)
      @communication_work_order.created_by = current_admin_user.id
      
      if @communication_work_order.save
        redirect_to admin_communication_work_order_path(@communication_work_order), notice: "沟通工单已创建"
      else
        render :new
      end
    end
    
    def edit
    end
    
    def update
      if @communication_work_order.update(communication_work_order_params)
        redirect_to admin_communication_work_order_path(@communication_work_order), notice: "沟通工单已更新"
      else
        render :edit
      end
    end
    
    def destroy
      @communication_work_order.destroy
      redirect_to admin_communication_work_orders_path, notice: "沟通工单已删除"
    end
    
    def start_communication
      service = CommunicationWorkOrderService.new(@communication_work_order, current_admin_user)
      
      if service.start_communication
        redirect_to admin_communication_work_order_path(@communication_work_order), notice: "工单已开始沟通"
      else
        redirect_to admin_communication_work_order_path(@communication_work_order), alert: "操作失败"
      end
    end
    
    def resolve
      render "admin/communication_work_orders/resolve"
    end
    
    def do_resolve
      service = CommunicationWorkOrderService.new(@communication_work_order, current_admin_user)
      
      if service.resolve(params[:resolution_summary])
        redirect_to admin_communication_work_order_path(@communication_work_order), notice: "工单已标记为已解决"
      else
        redirect_to admin_communication_work_order_path(@communication_work_order), alert: "操作失败"
      end
    end
    
    def mark_unresolved
      render "admin/communication_work_orders/mark_unresolved"
    end
    
    def do_mark_unresolved
      service = CommunicationWorkOrderService.new(@communication_work_order, current_admin_user)
      
      if service.mark_unresolved(params[:resolution_summary])
        redirect_to admin_communication_work_order_path(@communication_work_order), notice: "工单已标记为未解决"
      else
        redirect_to admin_communication_work_order_path(@communication_work_order), alert: "操作失败"
      end
    end
    
    def close
      service = CommunicationWorkOrderService.new(@communication_work_order, current_admin_user)
      
      if service.close
        redirect_to admin_communication_work_order_path(@communication_work_order), notice: "工单已关闭"
      else
        redirect_to admin_communication_work_order_path(@communication_work_order), alert: "操作失败"
      end
    end
    
    def new_communication_record
      render "admin/communication_work_orders/new_communication_record"
    end
    
    def create_communication_record
      service = CommunicationWorkOrderService.new(@communication_work_order, current_admin_user)
      
      communication_record = service.add_communication_record(
        content: params[:content],
        communicator_role: params[:communicator_role],
        communicator_name: params[:communicator_name],
        communication_method: params[:communication_method]
      )
      
      if communication_record.persisted?
        redirect_to admin_communication_work_order_path(@communication_work_order), notice: "沟通记录已添加"
      else
        redirect_to admin_communication_work_order_path(@communication_work_order), alert: "添加沟通记录失败: #{communication_record.errors.full_messages.join(', ')}"
      end
    end
    
    def resolve_fee_detail_issue
      service = CommunicationWorkOrderService.new(@communication_work_order, current_admin_user)
      
      if service.resolve_fee_detail_issue(params[:fee_detail_id], params[:resolution])
        redirect_to admin_communication_work_order_path(@communication_work_order), notice: "费用明细问题已解决"
      else
        redirect_to admin_communication_work_order_path(@communication_work_order), alert: "解决费用明细问题失败"
      end
    end
    
    def select_fee_detail
      service = CommunicationWorkOrderService.new(@communication_work_order, current_admin_user)
      
      if service.select_fee_detail(params[:fee_detail_id])
        redirect_to admin_communication_work_order_path(@communication_work_order), notice: "费用明细已选择"
      else
        redirect_to admin_communication_work_order_path(@communication_work_order), alert: "选择费用明细失败"
      end
    end
    
    private
    
    def set_communication_work_order
      @communication_work_order = CommunicationWorkOrder.find(params[:id])
    end
    
    def communication_work_order_params
      params.require(:communication_work_order).permit(
        :reimbursement_id, 
        :audit_work_order_id, 
        :status, 
        :communication_method, 
        :initiator_role, 
        :resolution_summary
      )
    end
  end
end
```

### 3. 创建沟通工单视图

创建 `app/views/admin/communication_work_orders/resolve.html.erb` 文件：

```erb
<!-- app/views/admin/communication_work_orders/resolve.html.erb -->
<h2>标记为已解决</h2>

<%= form_tag do_resolve_admin_communication_work_order_path(@communication_work_order), method: :post do %>
  <div class="panel">
    <div class="panel_contents">
      <div class="attributes_table">
        <table>
          <tr>
            <th>报销单号</th>
            <td><%= @communication_work_order.reimbursement.invoice_number %></td>
          </tr>
          <tr>
            <th>申请人</th>
            <td><%= @communication_work_order.reimbursement.applicant %></td>
          </tr>
          <tr>
            <th>解决方案</th>
            <td><%= text_area_tag :resolution_summary, nil, rows: 5, cols: 50, required: true %></td>
          </tr>
        </table>
      </div>
    </div>
  </div>
  
  <div class="actions">
    <%= submit_tag "确认已解决", class: "button" %>
    <%= link_to "取消", admin_communication_work_order_path(@communication_work_order), class: "button" %>
  </div>
<% end %>
```

创建 `app/views/admin/communication_work_orders/mark_unresolved.html.erb` 文件：

```erb
<!-- app/views/admin/communication_work_orders/mark_unresolved.html.erb -->
<h2>标记为未解决</h2>

<%= form_tag do_mark_unresolved_admin_communication_work_order_path(@communication_work_order), method: :post do %>
  <div class="panel">
    <div class="panel_contents">
      <div class="attributes_table">
        <table>
          <tr>
            <th>报销单号</th>
            <td><%= @communication_work_order.reimbursement.invoice_number %></td>
          </tr>
          <tr>
            <th>申请人</th>
            <td><%= @communication_work_order.reimbursement.applicant %></td>
          </tr>
          <tr>
            <th>未解决原因</th>
            <td><%= text_area_tag :resolution_summary, nil, rows: 5, cols: 50, required: true %></td>
          </tr>
        </table>
      </div>
    </div>
  </div>
  
  <div class="actions">
    <%= submit_tag "确认未解决", class: "button" %>
    <%= link_to "取消", admin_communication_work_order_path(@communication_work_order), class: "button" %>
  </div>
<% end %>
```

创建 `app/views/admin/communication_work_orders/new_communication_record.html.erb` 文件：

```erb
<!-- app/views/admin/communication_work_orders/new_communication_record.html.erb -->
<h2>添加沟通记录</h2>

<%= form_tag create_communication_record_admin_communication_work_order_path(@communication_work_order), method: :post do %>
  <div class="panel">
    <div class="panel_contents">
      <div class="attributes_table">
        <table>
          <tr>
            <th>沟通内容</th>
            <td><%= text_area_tag :content, nil, rows: 5, cols: 50, required: true %></td>
          </tr>
          <tr>
            <th>沟通角色</th>
            <td>
              <%= select_tag :communicator_role, options_for_select([
                ["审核人", "auditor"],
                ["申请人", "applicant"],
                ["管理员", "admin"],
                ["其他", "other"]
              ]), required: true %>
            </td>
          </tr>
          <tr>
            <th>沟通人姓名</th>
            <td><%= text_field_tag :communicator_name, current_admin_user.email %></td>
          </tr>
          <tr>
            <th>沟通方式</th>
            <td>
              <%= select_tag :communication_method, options_for_select([
                ["系统", "system"],
                ["邮件", "email"],
                ["电话", "phone"],
                ["其他", "other"]
              ]), required: true %>
            </td>
          </tr>
        </table>
      </div>
    </div>
  </div>
  
  <div class="actions">
    <%= submit_tag "添加记录", class: "button" %>
    <%= link_to "取消", admin_communication_work_order_path(@communication_work_order), class: "button" %>
  </div>
<% end %>
```

### 4. 更新路由配置

修改 `config/routes.rb` 文件，添加沟通工单处理路由：

```ruby
# config/routes.rb
Rails.application.routes.draw do
  # ...
  
  namespace :admin do
    resources :communication_work_orders do
      member do
        put :start_communication
        get :resolve
        post :do_resolve
        get :mark_unresolved
        post :do_mark_unresolved
        put :close
        get :new_communication_record
        post :create_communication_record
        post :resolve_fee_detail_issue
        post :select_fee_detail
      end
    end
    # ...
  end
  
  # ...
end
```

### 5. 创建沟通工单处理服务测试

创建 `spec/services/communication_work_order_service_spec.rb` 文件：

```ruby
# spec/services/communication_work_order_service_spec.rb
require 'rails_helper'

RSpec.describe CommunicationWorkOrderService do
  let(:admin_user) { create(:admin_user) }
  let(:reimbursement) { create(:reimbursement) }
  let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement, status: 'needs_communication') }
  let(:communication_work_order) { create(:communication_work_order, reimbursement: reimbursement, audit_work_order: audit_work_order, status: 'open') }
  let(:service) { CommunicationWorkOrderService.new(communication_work_order, admin_user) }
  
  describe '#start_communication' do
    it 'changes status to in_progress' do
      expect {
        service.start_communication
      }.to change { communication_work_order.reload.status }.from('open').to('in_progress')
    end
    
    it 'returns false if status transition is invalid' do
      communication_work_order.update(status: 'closed')
      expect(service.start_communication).to be false
    end
  end
  
  describe '#resolve' do
    before do
      communication_work_order.update(status: 'in_progress')
    end
    
    it 'changes status to resolved' do
      expect {
        service.resolve("问题已解决")
      }.to change { communication_work_order.reload.status }.from('in_progress').to('resolved')
    end
    
    it 'updates resolution summary' do
      service.resolve("问题已解决")
      communication_work_order.reload
      
      expect(communication_work_order.resolution_summary).to eq("问题已解决")
    end
    
    it 'notifies parent work order' do
      expect {
        service.resolve
      }.to change { audit_work_order.reload.status }.from('needs_communication').to('auditing')
    end
    
    it 'returns false if status transition is invalid' do
      communication_work_order.update(status: 'open')
      expect(service.resolve).to be false
    end
  end
  
  describe '#mark_unresolved' do
    before do
      communication_work_order.update(status: 'in_progress')
    end
    
    it 'changes status to unresolved' do
      expect {
        service.mark_unresolved("问题无法解决")
      }.to change { communication_work_order.reload.status }.from('in_progress').to('unresolved')
    end
    
    it 'updates resolution summary' do
      service.mark_unresolved("问题无法解决")
      communication_work_order.reload
      
      expect(communication_work_order.resolution_summary).to eq("问题无法解决")
    end
    
    it 'notifies parent work order' do
      expect {
        service.mark_unresolved
      }.to change { audit_work_order.reload.status }.from('needs_communication').to('auditing')
    end
    
    it 'returns false if status transition is invalid' do
      communication_work_order.update(status: 'open')
      expect(service.mark_unresolved).to be false
    end
  end
  
  describe '#close' do
    before do
      communication_work_order.update(status: 'resolved')
    end
    
    it 'changes status to closed' do
      expect {
        service.close
      }.to change { communication_work_order.reload.status }.from('resolved').to('closed')
    end
    
    it 'returns false if status transition is invalid' do
      communication_work_order.update(status: 'open')
      expect(service.close).to be false
    end
  end
  
  describe '#add_communication_record' do
    it 'creates a communication record' do
      expect {
        service.add_communication_record(
          content: "测试沟通内容",
          communicator_role: "auditor",
          communicator_name: admin_user.email,
          communication_method: "system"
        )
      }.to change(CommunicationRecord, :count).by(1)
    end
    
    it 'sets correct attributes on the communication record' do
      record = service.add_communication_record(
        content: "测试沟通内容",
        communicator_role: "auditor",
        communicator_name: admin_user.email,
        communication_method: "system"
      )
      
      expect(record.content).to eq("测试沟通内容")
      expect(record.communicator_role).to eq("auditor")
      expect(record.communicator_name).to eq(admin_user.email)
      expect(record.communication_method).to eq("system")
      expect(record.recorded_at).to be_present
    end
  end
  
  describe '#resolve_fee_detail_issue' do
    before do
      @fee_detail = create(:fee_detail, document_number: reimbursement.invoice_number, verification_status: 'problematic')
      @selection = create(:fee_detail_selection, fee_detail: @fee_detail, communication_work_order: communication_work_order, verification_status: 'problematic')
    end
    
    it 'updates fee detail selection verification comment' do
      expect {
        service.resolve_fee_detail_issue(@fee_detail.id, "问题已解决")
      }.to change { @selection.reload.verification_comment }.to("问题已解决")
    end
    
    it 'does not change fee detail verification status' do
      expect {
        service.resolve_fee_detail_issue(@fee_detail.id, "问题已解决")
      }.not_to change { @fee_detail.reload.verification_status }
    end
  end
  
  describe '#select_fee_detail' do
    before do
      @fee_detail = create(:fee_detail, document_number: reimbursement.invoice_number)
    end
    
    it 'creates a fee detail selection' do
      expect {
        service.select_fee_detail(@fee_detail.id)
      }.to change(FeeDetailSelection, :count).by(1)
    end
    
    it 'sets verification status to problematic' do
      selection = service.select_fee_detail(@fee_detail.id)
      expect(selection.verification_status).to eq('problematic')
    end
  end
end
```

## 测试验证方法

1. 运行 `rspec spec/services/communication_work_order_service_spec.rb` 确保所有测试通过
2. 在 Rails 控制台中测试服务功能：
   ```ruby
   # 创建测试报销单
   reimbursement = Reimbursement.create!(
     invoice_number: "R20250101001",
     document_name: "测试报销单",
     applicant: "张三",
     applicant_id: "EMP001",
     company: "测试公司",
     department: "测试部门",
     amount: 1000.00,
     is_electronic: false,
     is_complete: false,
     reimbursement_status: 'processing'
   )
   
   # 创建测试审核工单
   audit_work_order = AuditWorkOrder.create!(
     reimbursement: reimbursement,
     status: 'needs_communication',
     created_by: 1
   )
   
   # 创建测试沟通工单
   communication_work_order = CommunicationWorkOrder.create!(
     reimbursement: reimbursement,
     audit_work_order: audit_work_order,
     status: 'open',
     created_by: 1
   )
   
   # 创建测试费用明细
   fee_detail = FeeDetail.create!(
     document_number: reimbursement.invoice_number,
     fee_type: "交通费",
     amount: 100.00,
     currency: "CNY",
     verification_status: "problematic"
   )
   
   # 创建费用明细选择
   fee_detail_selection = FeeDetailSelection.create!(
     fee_detail: fee_detail,
     communication_work_order: communication_work_order,
     verification_status: 'problematic'
   )
   
   # 创建管理员用户
   admin_user = AdminUser.first || AdminUser.create!(email: 'admin@example.com', password: 'password')
   
   # 创建服务实例
   service = CommunicationWorkOrderService.new(communication_work_order, admin_user)
   
   # 测试状态流转
   service.start_communication
   puts "工单状态: #{communication_work_order.reload.status}"
   
   # 测试添加沟通记录
   record = service.add_communication_record(
     content: "测试沟通内容",
     communicator_role: "auditor",
     communicator_name: admin_user.email,
     communication_method: "system"
   )
   puts "沟通记录ID: #{record.id}"
   puts "沟通记录内容: #{record.content}"
   
   # 测试解决费用明细问题
   service.resolve_fee_detail_issue(fee_detail.id, "问题已解决")
   puts "费用明细选择验证意见: #{fee_detail_selection.reload.verification_comment}"
   
   # 测试解决沟通工单
   service.resolve("沟通已解决")
   puts "工单状态: #{communication_work_order.reload.status}"
   puts "解决方案: #{communication_work_order.resolution_summary}"
   puts "审核工单状态: #{audit_work_order.reload.status}"
   
   # 测试关闭沟通工单
   service.close
   puts "工单状态: #{communication_work_order.reload.status}"
   ```
3. 启动 Rails 服务器，访问 ActiveAdmin 界面，测试沟通工单处理功能

## 注意事项

1. 确保状态流转功能正确实现，特别是状态转换的条件和回调
2. 确保沟通记录添加功能正确实现，特别是记录的创建和关联
3. 确保费用明细问题解决功能正确实现，特别是验证状态的更新和记录
4. 确保通知父工单（审核工单）功能正确实现，特别是状态的同步
5. 确保错误处理和验证功能正确实现，特别是非法状态转换的处理
6. 确保服务与控制器的交互正确实现，特别是参数的传递和结果的处理
7. 确保视图正确实现，特别是表单的提交和数据的显示
8. 注意沟通工单解决后不会自动更新费用明细状态，需要审核人员手动更新