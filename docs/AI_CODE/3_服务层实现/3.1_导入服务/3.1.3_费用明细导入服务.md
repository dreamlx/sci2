# 费用明细导入服务实现

## 任务描述

实现费用明细导入服务（FeeDetailImportService），负责从Excel或CSV文件中导入费用明细数据到系统中，并关联到对应的报销单和审核工单。该服务需要处理未匹配到报销单的费用明细记录，并提供错误处理和报告功能。

## 输入和依赖

- 基础模型（Reimbursement, FeeDetail, AuditWorkOrder）
- Roo gem（用于处理Excel文件）
- 服务层设计文档 (`docs/refactoring/04_service_implementation.md`)

## 期望输出

完整的费用明细导入服务实现，包括：
- 文件解析功能
- 报销单匹配逻辑
- 费用明细创建逻辑
- 与审核工单的自动关联
- 未匹配记录处理
- 错误处理和报告
- 单元测试

## 详细实现步骤

### 1. 创建费用明细导入服务

创建 `app/services/fee_detail_import_service.rb` 文件：

```ruby
class FeeDetailImportService
  attr_reader :imported_count, :unmatched_count, :error_count, :errors, :unmatched_details

  def initialize(file, current_admin_user)
    @file = file
    @current_admin_user = current_admin_user
    @imported_count = 0
    @unmatched_count = 0
    @error_count = 0
    @errors = []
    @unmatched_details = []
  end

  def import
    return { success: false, errors: ["文件不存在"] } unless @file.present?

    begin
      spreadsheet = open_spreadsheet
      header = spreadsheet.row(1)
      
      # 将头部转换为符号形式，方便后续使用
      header_symbols = header.map { |h| h.to_s.strip.gsub(/\s+/, '_').downcase.to_sym }
      
      (2..spreadsheet.last_row).each do |i|
        row = Hash[[header_symbols, spreadsheet.row(i)].transpose]
        import_fee_detail(row, i)
      end

      {
        success: true,
        imported: @imported_count,
        unmatched: @unmatched_count,
        errors: @error_count,
        error_details: @errors,
        unmatched_details: @unmatched_details
      }
    rescue => e
      Rails.logger.error "费用明细导入错误: #{e.message}\n#{e.backtrace.join("\n")}"
      { success: false, errors: [e.message] }
    end
  end

  private

  def open_spreadsheet
    case File.extname(@file.original_filename)
    when '.csv'
      Roo::CSV.new(@file.path, csv_options: {encoding: 'utf-8'})
    when '.xls'
      Roo::Excel.new(@file.path)
    when '.xlsx'
      Roo::Excelx.new(@file.path)
    else
      raise "未知的文件类型: #{@file.original_filename}"
    end
  end

  def import_fee_detail(row, row_number)
    # 获取报销单号
    document_number = extract_document_number(row)

    # 检查必要字段
    unless document_number.present?
      @error_count += 1
      @errors << "行 #{row_number}: 报销单单号不能为空"
      return
    end

    # 检查费用类型和金额
    fee_type = extract_fee_type(row)
    amount = extract_amount(row)

    unless fee_type.present? && amount.present?
      @error_count += 1
      @errors << "行 #{row_number}: 费用类型和金额不能为空"
      return
    end

    # 查找对应的报销单
    reimbursement = Reimbursement.find_by(invoice_number: document_number)

    unless reimbursement
      # 记录未匹配的费用明细
      @unmatched_count += 1
      @unmatched_details << {
        original_data: row,
        document_number: document_number,
        error: "报销单不存在"
      }
      return
    end

    # 创建费用明细记录
    fee_detail = create_fee_detail(row, document_number)
    
    if fee_detail.persisted?
      @imported_count += 1
      
      # 关联到审核工单
      associate_with_audit_work_orders(fee_detail, reimbursement)
    else
      @error_count += 1
      @errors << "行 #{row_number}: 创建费用明细失败 - #{fee_detail.errors.full_messages.join(', ')}"
    end
  end

  def create_fee_detail(row, document_number)
    FeeDetail.create(
      document_number: document_number,
      fee_type: extract_fee_type(row),
      amount: extract_amount(row),
      currency: extract_currency(row) || 'CNY',
      fee_date: parse_date(extract_fee_date(row)),
      payment_method: extract_payment_method(row),
      verification_status: 'pending'
    )
  end

  def associate_with_audit_work_orders(fee_detail, reimbursement)
    # 查找该报销单的所有未完成的审核工单
    audit_work_orders = AuditWorkOrder.where(reimbursement_id: reimbursement.id)
                                      .where.not(status: 'completed')

    # 关联到所有处于pending、processing、auditing或needs_communication状态的审核工单
    audit_work_orders.where(status: ['pending', 'processing', 'auditing', 'needs_communication']).each do |audit_work_order|
      # 使用审核工单的select_fee_detail方法关联费用明细
      audit_work_order.select_fee_detail(fee_detail)
    end
  end

  def extract_document_number(row)
    row[:报销单单号] || row[:单据编号] || row[:document_number] || ''
  end

  def extract_fee_type(row)
    row[:费用类型] || row[:fee_type] || ''
  end

  def extract_amount(row)
    amount_value = row[:原始金额] || row[:金额] || row[:amount]
    return nil unless amount_value.present?
    
    # 确保金额是数字
    begin
      amount_value.to_f
    rescue
      nil
    end
  end

  def extract_currency(row)
    row[:币种] || row[:currency] || 'CNY'
  end

  def extract_fee_date(row)
    row[:费用发生日期] || row[:费用日期] || row[:fee_date]
  end

  def extract_payment_method(row)
    row[:支付方式] || row[:弹性字段11] || row[:payment_method] || '其他'
  end

  def parse_date(date_string)
    return nil unless date_string.present?
    
    begin
      if date_string.is_a?(String)
        Date.parse(date_string)
      else
        date_string # 可能已经是日期对象
      end
    rescue ArgumentError
      nil
    end
  end
end
```

### 2. 创建费用明细导入服务测试

创建 `spec/services/fee_detail_import_service_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe FeeDetailImportService, type: :service do
  let(:admin_user) { create(:admin_user) }
  let(:file_path) { Rails.root.join('spec', 'fixtures', 'files', 'test_fee_details.xlsx') }
  let(:file) { fixture_file_upload(file_path, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') }
  
  # 准备测试文件和数据
  before do
    # 确保测试目录存在
    FileUtils.mkdir_p(Rails.root.join('spec', 'fixtures', 'files'))
    
    # 创建测试报销单
    @reimbursement1 = create(:reimbursement, invoice_number: 'R20250101001')
    @reimbursement2 = create(:reimbursement, invoice_number: 'R20250101002')
    
    # 创建测试审核工单
    @audit_work_order1 = create(:audit_work_order, reimbursement: @reimbursement1, status: 'pending')
    @audit_work_order2 = create(:audit_work_order, reimbursement: @reimbursement2, status: 'processing')
    
    # 创建测试Excel文件（如果不存在）
    unless File.exist?(file_path)
      workbook = WriteXLSX.new(file_path)
      worksheet = workbook.add_worksheet
      
      # 添加表头
      headers = ['报销单单号', '费用类型', '原始金额', '币种', '费用发生日期', '支付方式']
      headers.each_with_index do |header, index|
        worksheet.write(0, index, header)
      end
      
      # 添加数据行
      data = [
        ['R20250101001', '交通费', 100.0, 'CNY', '2025-01-01', '现金'],
        ['R20250101001', '餐饮费', 200.0, 'CNY', '2025-01-01', '公司卡'],
        ['R20250101002', '住宿费', 500.0, 'CNY', '2025-01-02', '个人卡'],
        ['R20250101003', '办公用品', 50.0, 'CNY', '2025-01-03', '现金']
      ]
      
      data.each_with_index do |row, row_index|
        row.each_with_index do |value, col_index|
          worksheet.write(row_index + 1, col_index, value)
        end
      end
      
      workbook.close
    end
  end
  
  describe '#import' do
    context '当文件不存在时' do
      it '返回错误信息' do
        service = FeeDetailImportService.new(nil, admin_user)
        result = service.import
        
        expect(result[:success]).to be_falsey
        expect(result[:errors]).to include('文件不存在')
      end
    end
    
    context '当文件格式不支持时' do
      let(:invalid_file) { fixture_file_upload(Rails.root.join('spec', 'fixtures', 'files', 'test.txt'), 'text/plain') }
      
      it '返回错误信息' do
        allow(File).to receive(:extname).and_return('.txt')
        
        service = FeeDetailImportService.new(invalid_file, admin_user)
        expect { service.import }.to raise_error(/未知的文件类型/)
      end
    end
    
    context '当文件有效时' do
      it '导入费用明细数据' do
        service = FeeDetailImportService.new(file, admin_user)
        
        expect {
          result = service.import
          expect(result[:success]).to be_truthy
          expect(result[:imported]).to eq(3) # 只有三个费用明细能匹配到报销单
          expect(result[:unmatched]).to eq(1) # 一个费用明细对应的报销单不存在
          expect(result[:errors]).to eq(0)
        }.to change(FeeDetail, :count).by(3)
         .and change(FeeDetailSelection, :count).by(3) # 每个费用明细都会关联到一个审核工单
      end
      
      it '关联费用明细到审核工单' do
        service = FeeDetailImportService.new(file, admin_user)
        service.import
        
        # 检查第一个报销单的审核工单是否关联了两个费用明细
        expect(@audit_work_order1.fee_details.count).to eq(2)
        expect(@audit_work_order1.fee_details.pluck(:fee_type)).to include('交通费', '餐饮费')
        
        # 检查第二个报销单的审核工单是否关联了一个费用明细
        expect(@audit_work_order2.fee_details.count).to eq(1)
        expect(@audit_work_order2.fee_details.pluck(:fee_type)).to include('住宿费')
      end
      
      it '记录未匹配的费用明细' do
        service = FeeDetailImportService.new(file, admin_user)
        result = service.import
        
        expect(result[:unmatched]).to eq(1)
        expect(result[:unmatched_details].size).to eq(1)
        expect(result[:unmatched_details][0][:document_number]).to eq('R20250101003')
        expect(result[:unmatched_details][0][:error]).to eq('报销单不存在')
      end
      
      it '处理缺少必要字段的行' do
        # 创建一个缺少费用类型的测试文件
        invalid_file_path = Rails.root.join('spec', 'fixtures', 'files', 'invalid_fee_details.xlsx')
        workbook = WriteXLSX.new(invalid_file_path)
        worksheet = workbook.add_worksheet
        
        # 添加表头
        headers = ['报销单单号', '费用类型', '原始金额', '币种', '费用发生日期', '支付方式']
        headers.each_with_index do |header, index|
          worksheet.write(0, index, header)
        end
        
        # 添加数据行（缺少费用类型）
        worksheet.write(1, 0, 'R20250101001')
        worksheet.write(1, 1, nil)
        worksheet.write(1, 2, 100.0)
        worksheet.write(1, 3, 'CNY')
        worksheet.write(1, 4, '2025-01-01')
        worksheet.write(1, 5, '现金')
        
        workbook.close
        
        invalid_file = fixture_file_upload(invalid_file_path, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
        service = FeeDetailImportService.new(invalid_file, admin_user)
        
        result = service.import
        expect(result[:success]).to be_truthy
        expect(result[:imported]).to eq(0)
        expect(result[:errors]).to eq(1)
        expect(result[:error_details]).to include(/行 2: 费用类型和金额不能为空/)
      end
    end
  end
  
  describe '私有方法' do
    let(:service) { FeeDetailImportService.new(file, admin_user) }
    let(:sample_row) { {
      报销单单号: 'R20250101001',
      费用类型: '交通费',
      原始金额: 100.0,
      币种: 'CNY',
      费用发生日期: '2025-01-01',
      支付方式: '现金'
    } }
    
    describe '#extract_document_number' do
      it '提取报销单号' do
        expect(service.send(:extract_document_number, sample_row)).to eq('R20250101001')
        expect(service.send(:extract_document_number, { 单据编号: 'R20250101002' })).to eq('R20250101002')
        expect(service.send(:extract_document_number, { document_number: 'R20250101003' })).to eq('R20250101003')
        expect(service.send(:extract_document_number, {})).to eq('')
      end
    end
    
    describe '#extract_fee_type' do
      it '提取费用类型' do
        expect(service.send(:extract_fee_type, sample_row)).to eq('交通费')
        expect(service.send(:extract_fee_type, { fee_type: '餐饮费' })).to eq('餐饮费')
        expect(service.send(:extract_fee_type, {})).to eq('')
      end
    end
    
    describe '#extract_amount' do
      it '提取金额' do
        expect(service.send(:extract_amount, sample_row)).to eq(100.0)
        expect(service.send(:extract_amount, { 金额: 200.0 })).to eq(200.0)
        expect(service.send(:extract_amount, { amount: 300.0 })).to eq(300.0)
        expect(service.send(:extract_amount, {})).to be_nil
      end
    end
    
    describe '#parse_date' do
      it '解析日期' do
        expect(service.send(:parse_date, '2025-01-01')).to eq(Date.parse('2025-01-01'))
        expect(service.send(:parse_date, Date.parse('2025-01-01'))).to eq(Date.parse('2025-01-01'))
        expect(service.send(:parse_date, 'invalid date')).to be_nil
        expect(service.send(:parse_date, nil)).to be_nil
      end
    end
  end
end
```

### 3. 创建 ActiveAdmin 导入界面

在 `app/admin/fee_details.rb` 文件中添加导入功能：

```ruby
ActiveAdmin.register FeeDetail do
  # ... 其他配置 ...

  # 自定义操作
  action_item :import, only: :index do
    link_to "导入费用明细", new_import_admin_fee_details_path
  end

  # 自定义页面
  collection_action :new_import, method: :get do
    render "admin/fee_details/new_import"
  end

  collection_action :import, method: :post do
    # 调用导入服务
    service = FeeDetailImportService.new(params[:file], current_admin_user)
    result = service.import
    
    if result[:success]
      if result[:unmatched] > 0
        redirect_to admin_fee_details_path, notice: "导入成功: #{result[:imported]} 导入, #{result[:unmatched]} 未匹配, #{result[:errors]} 错误. 未匹配的费用明细对应的报销单不存在."
      else
        redirect_to admin_fee_details_path, notice: "导入成功: #{result[:imported]} 导入, #{result[:unmatched]} 未匹配, #{result[:errors]} 错误."
      end
    else
      redirect_to new_import_admin_fee_details_path, alert: "导入失败: #{result[:errors].join(', ')}"
    end
  end

  # ... 其他配置 ...
end
```

创建 `app/views/admin/fee_details/new_import.html.erb` 文件：

```erb
<h2>导入费用明细</h2>

<%= form_tag import_admin_fee_details_path, multipart: true do %>
  <div class="panel">
    <div class="panel_contents">
      <div class="attributes_table">
        <table>
          <tr>
            <th>选择文件</th>
            <td><%= file_field_tag :file, accept: '.csv,.xlsx,.xls', required: true %></td>
          </tr>
        </table>
      </div>
    </div>
  </div>

  <div class="actions">
    <%= submit_tag "导入", class: "button" %>
    <%= link_to "取消", admin_fee_details_path, class: "button" %>
  </div>
<% end %>

<div class="panel">
  <h3>导入说明</h3>
  <div class="panel_contents">
    <p>CSV或Excel文件应包含以下列：</p>
    <ul>
      <li>报销单单号/单据编号（必填）</li>
      <li>费用类型（必填）</li>
      <li>原始金额/金额（必填）</li>
      <li>币种（可选，默认CNY）</li>
      <li>费用发生日期（可选）</li>
      <li>支付方式（可选）</li>
    </ul>
    <p>注意：导入的费用明细将自动关联到对应报销单的审核工单中。</p>
  </div>
</div>
```

## 测试验证方法

1. 运行 `rspec spec/services/fee_detail_import_service_spec.rb` 确保所有测试通过
2. 在 Rails 控制台中测试服务功能：

```ruby
# 假设已经有一个测试文件
file_path = Rails.root.join('spec', 'fixtures', 'files', 'test_fee_details.xlsx')
file = File.open(file_path)
admin_user = AdminUser.first

# 创建测试报销单
reimbursement1 = Reimbursement.create!(
  invoice_number: 'R20250101001',
  document_name: '测试报销单1',
  applicant: '张三',
  applicant_id: 'EMP001',
  company: '测试公司',
  department: '测试部门',
  amount: 1000.00
)

reimbursement2 = Reimbursement.create!(
  invoice_number: 'R20250101002',
  document_name: '测试报销单2',
  applicant: '李四',
  applicant_id: 'EMP002',
  company: '测试公司',
  department: '财务部',
  amount: 2000.00
)

# 创建测试审核工单
audit_work_order1 = AuditWorkOrder.create!(
  reimbursement: reimbursement1,
  status: 'pending',
  created_by: admin_user.id
)

audit_work_order2 = AuditWorkOrder.create!(
  reimbursement: reimbursement2,
  status: 'processing',
  created_by: admin_user.id
)

# 创建服务实例
service = FeeDetailImportService.new(file, admin_user)

# 执行导入
result = service.import
puts "导入结果: #{result.inspect}"

# 检查导入的费用明细
fee_details = FeeDetail.last(3)
fee_details.each do |fd|
  puts "费用明细 #{fd.id}: 报销单 #{fd.document_number}, 费用类型: #{fd.fee_type}, 金额: #{fd.amount}, 状态: #{fd.verification_status}"
end

# 检查审核工单关联的费用明细
audit_work_order1.reload
audit_work_order2.reload
puts "审核工单1 关联的费用明细数量: #{audit_work_order1.fee_details.count}"
puts "审核工单2 关联的费用明细数量: #{audit_work_order2.fee_details.count}"

# 检查费用明细选择记录
fee_detail_selections = FeeDetailSelection.last(3)
fee_detail_selections.each do |fds|
  puts "费用明细选择 #{fds.id}: 费用明细 #{fds.fee_detail_id}, 审核工单: #{fds.audit_work_order_id}, 状态: #{fds.verification_status}"
end
```

3. 启动 Rails 服务器，访问 ActiveAdmin 界面，测试费用明细导入功能

## 注意事项

1. 确保 Roo gem 正确安装和配置
2. 确保导入逻辑正确处理各种边缘情况，如缺少必要字段、格式错误等
3. 确保费用明细与审核工单的关联逻辑正确实现
4. 确保未匹配记录的处理逻辑正确实现
5. 确保错误处理和日志记录功能正确实现
6. 确保测试覆盖所有关键功能，特别是文件解析、数据导入和审核工单关联
7. 考虑大文件导入的性能问题，可能需要使用批量导入或后台任务