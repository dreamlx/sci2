# 费用明细验证服务实现

## 任务描述

实现费用明细验证服务（FeeDetailVerificationService），负责处理费用明细的验证业务逻辑，包括更新验证状态、批量验证等。该服务封装了费用明细验证的所有操作，提供清晰的接口供其他服务和控制器调用。

## 输入和依赖

- 基础模型（FeeDetail, FeeDetailSelection）
- 服务层设计文档 (`docs/refactoring/04_service_implementation.md`)

## 期望输出

完整的费用明细验证服务实现，包括：
- 单个费用明细验证状态更新方法
- 批量费用明细验证方法
- 错误处理和报告
- 单元测试

## 详细实现步骤

### 1. 创建费用明细验证服务

创建 `app/services/fee_detail_verification_service.rb` 文件：

```ruby
class FeeDetailVerificationService
  attr_reader :current_admin_user

  def initialize(current_admin_user)
    @current_admin_user = current_admin_user
  end

  # 批量验证费用明细
  def verify_fee_details(fee_detail_ids, verification_status, comment = nil)
    results = { success: 0, failure: 0, errors: [] }
    
    FeeDetail.where(id: fee_detail_ids).each do |fee_detail|
      if update_verification_status(fee_detail, verification_status, comment)
        results[:success] += 1
      else
        results[:failure] += 1
        results[:errors] << "费用明细 ##{fee_detail.id} 更新失败: #{fee_detail.errors.full_messages.join(', ')}"
      end
    end
    
    results
  end

  # 更新单个费用明细的验证状态
  def update_verification_status(fee_detail, verification_status, comment = nil)
    # 检查关联报销单是否已关闭
    if fee_detail.reimbursement&.is_complete?
      fee_detail.errors.add(:base, "关联报销单已关闭，无法修改费用明细状态")
      return false
    end

    # 检查状态是否有效
    valid_statuses = ['pending', 'verified', 'rejected', 'problematic'] # 或使用模型中定义的常量
    unless valid_statuses.include?(verification_status)
      fee_detail.errors.add(:verification_status, "无效的状态")
      return false
    end

    # 使用事务确保数据一致性
    ActiveRecord::Base.transaction do
      # 更新 FeeDetail 自身状态
      fee_detail.verification_status = verification_status
      unless fee_detail.save
        # 如果保存失败，回滚事务
        raise ActiveRecord::Rollback
      end

      # 更新所有关联的 FeeDetailSelection 记录
      fee_detail.fee_detail_selections.each do |selection|
        selection.update(
          verification_status: verification_status,
          verification_comment: comment,
          verified_by: @current_admin_user.id,
          verified_at: Time.current
        )
      end
    end

    # 检查是否有错误
    fee_detail.errors.empty?
  end

  # 在工单中验证费用明细
  def verify_fee_detail_in_work_order(work_order, fee_detail_id, verification_status, comment = nil)
    fee_detail = FeeDetail.find_by(id: fee_detail_id)
    return false unless fee_detail
    
    # 查找关联的费用明细选择记录
    selection = work_order.fee_detail_selections.find_by(fee_detail_id: fee_detail_id)
    return false unless selection
    
    # 检查关联报销单是否已关闭
    if fee_detail.reimbursement&.is_complete?
      fee_detail.errors.add(:base, "关联报销单已关闭，无法修改费用明细状态")
      return false
    end
    
    # 检查状态是否有效
    valid_statuses = ['pending', 'verified', 'rejected', 'problematic'] # 或使用模型中定义的常量
    unless valid_statuses.include?(verification_status)
      fee_detail.errors.add(:verification_status, "无效的状态")
      return false
    end
    
    # 使用事务确保数据一致性
    ActiveRecord::Base.transaction do
      # 更新 FeeDetail 自身状态
      fee_detail.verification_status = verification_status
      unless fee_detail.save
        # 如果保存失败，回滚事务
        raise ActiveRecord::Rollback
      end
      
      # 更新费用明细选择记录
      selection.update(
        verification_status: verification_status,
        verification_comment: comment,
        verified_by: @current_admin_user.id,
        verified_at: Time.current
      )
    end
    
    # 检查是否有错误
    fee_detail.errors.empty?
  end

  # 获取费用明细的验证历史
  def get_verification_history(fee_detail)
    # 获取所有关联的费用明细选择记录，按验证时间排序
    fee_detail.fee_detail_selections.order(verified_at: :desc)
  end

  # 获取特定状态的费用明细
  def get_fee_details_by_status(status, reimbursement_id = nil)
    query = FeeDetail.where(verification_status: status)
    query = query.where(document_number: Reimbursement.find(reimbursement_id).invoice_number) if reimbursement_id
    query
  end
end
```

### 2. 创建费用明细验证服务测试

创建 `spec/services/fee_detail_verification_service_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe FeeDetailVerificationService, type: :service do
  let(:admin_user) { create(:admin_user) }
  let(:reimbursement) { create(:reimbursement, is_complete: false) }
  let(:fee_detail) { create(:fee_detail, document_number: reimbursement.invoice_number, verification_status: 'pending') }
  let(:service) { FeeDetailVerificationService.new(admin_user) }
  
  describe '#update_verification_status' do
    context '当报销单未关闭时' do
      it '成功更新验证状态' do
        expect(service.update_verification_status(fee_detail, 'verified', '验证通过')).to be_truthy
        expect(fee_detail.reload.verification_status).to eq('verified')
      end
      
      it '处理无效的状态' do
        expect(service.update_verification_status(fee_detail, 'invalid_status', '无效状态')).to be_falsey
        expect(fee_detail.errors[:verification_status]).to include('无效的状态')
        expect(fee_detail.reload.verification_status).to eq('pending')
      end
      
      it '更新关联的费用明细选择记录' do
        # 创建关联的费用明细选择记录
        audit_work_order = create(:audit_work_order, reimbursement: reimbursement)
        selection = create(:fee_detail_selection, fee_detail: fee_detail, audit_work_order: audit_work_order, verification_status: 'pending')
        
        service.update_verification_status(fee_detail, 'verified', '验证通过')
        
        selection.reload
        expect(selection.verification_status).to eq('verified')
        expect(selection.verification_comment).to eq('验证通过')
        expect(selection.verified_by).to eq(admin_user.id)
        expect(selection.verified_at).to be_present
      end
    end
    
    context '当报销单已关闭时' do
      before do
        reimbursement.update(is_complete: true)
      end
      
      it '拒绝更新验证状态' do
        expect(service.update_verification_status(fee_detail, 'verified', '验证通过')).to be_falsey
        expect(fee_detail.errors[:base]).to include('关联报销单已关闭，无法修改费用明细状态')
        expect(fee_detail.reload.verification_status).to eq('pending')
      end
    end
  end
  
  describe '#verify_fee_details' do
    let(:fee_detail1) { create(:fee_detail, document_number: reimbursement.invoice_number, verification_status: 'pending') }
    let(:fee_detail2) { create(:fee_detail, document_number: reimbursement.invoice_number, verification_status: 'pending') }
    
    it '批量更新验证状态' do
      result = service.verify_fee_details([fee_detail1.id, fee_detail2.id], 'verified', '批量验证通过')
      
      expect(result[:success]).to eq(2)
      expect(result[:failure]).to eq(0)
      expect(fee_detail1.reload.verification_status).to eq('verified')
      expect(fee_detail2.reload.verification_status).to eq('verified')
    end
    
    it '处理部分失败的情况' do
      # 将一个报销单标记为已完成
      reimbursement2 = create(:reimbursement, is_complete: true)
      fee_detail3 = create(:fee_detail, document_number: reimbursement2.invoice_number, verification_status: 'pending')
      
      result = service.verify_fee_details([fee_detail1.id, fee_detail3.id], 'verified', '批量验证通过')
      
      expect(result[:success]).to eq(1)
      expect(result[:failure]).to eq(1)
      expect(result[:errors]).to include(/关联报销单已关闭/)
      expect(fee_detail1.reload.verification_status).to eq('verified')
      expect(fee_detail3.reload.verification_status).to eq('pending')
    end
  end
  
  describe '#verify_fee_detail_in_work_order' do
    let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement) }
    let(:selection) { create(:fee_detail_selection, fee_detail: fee_detail, audit_work_order: audit_work_order, verification_status: 'pending') }
    
    before do
      # 确保选择记录存在
      selection
    end
    
    it '成功更新工单中的费用明细验证状态' do
      expect(service.verify_fee_detail_in_work_order(audit_work_order, fee_detail.id, 'verified', '工单中验证通过')).to be_truthy
      
      fee_detail.reload
      selection.reload
      
      expect(fee_detail.verification_status).to eq('verified')
      expect(selection.verification_status).to eq('verified')
      expect(selection.verification_comment).to eq('工单中验证通过')
      expect(selection.verified_by).to eq(admin_user.id)
      expect(selection.verified_at).to be_present
    end
    
    it '处理不存在的费用明细' do
      expect(service.verify_fee_detail_in_work_order(audit_work_order, 999, 'verified', '不存在的费用明细')).to be_falsey
    end
    
    it '处理未关联的费用明细' do
      another_fee_detail = create(:fee_detail, document_number: reimbursement.invoice_number)
      expect(service.verify_fee_detail_in_work_order(audit_work_order, another_fee_detail.id, 'verified', '未关联的费用明细')).to be_falsey
    end
    
    it '处理报销单已关闭的情况' do
      reimbursement.update(is_complete: true)
      expect(service.verify_fee_detail_in_work_order(audit_work_order, fee_detail.id, 'verified', '报销单已关闭')).to be_falsey
      expect(fee_detail.reload.verification_status).to eq('pending')
    end
  end
  
  describe '#get_verification_history' do
    it '获取费用明细的验证历史' do
      # 创建多个关联的费用明细选择记录
      audit_work_order1 = create(:audit_work_order, reimbursement: reimbursement)
      audit_work_order2 = create(:audit_work_order, reimbursement: reimbursement)
      
      selection1 = create(:fee_detail_selection, 
        fee_detail: fee_detail, 
        audit_work_order: audit_work_order1, 
        verification_status: 'verified',
        verification_comment: '第一次验证',
        verified_by: admin_user.id,
        verified_at: 2.days.ago
      )
      
      selection2 = create(:fee_detail_selection, 
        fee_detail: fee_detail, 
        audit_work_order: audit_work_order2, 
        verification_status: 'rejected',
        verification_comment: '第二次验证',
        verified_by: admin_user.id,
        verified_at: 1.day.ago
      )
      
      history = service.get_verification_history(fee_detail)
      
      expect(history.count).to eq(2)
      expect(history.first).to eq(selection2) # 按验证时间倒序排列
      expect(history.last).to eq(selection1)
    end
  end
  
  describe '#get_fee_details_by_status' do
    before do
      # 创建不同状态的费用明细
      @verified_fee_detail = create(:fee_detail, document_number: reimbursement.invoice_number, verification_status: 'verified')
      @rejected_fee_detail = create(:fee_detail, document_number: reimbursement.invoice_number, verification_status: 'rejected')
      @problematic_fee_detail = create(:fee_detail, document_number: reimbursement.invoice_number, verification_status: 'problematic')
      
      # 创建另一个报销单的费用明细
      @another_reimbursement = create(:reimbursement)
      @another_verified_fee_detail = create(:fee_detail, document_number: @another_reimbursement.invoice_number, verification_status: 'verified')
    end
    
    it '获取特定状态的所有费用明细' do
      verified_fee_details = service.get_fee_details_by_status('verified')
      
      expect(verified_fee_details.count).to eq(2)
      expect(verified_fee_details).to include(@verified_fee_detail, @another_verified_fee_detail)
    end
    
    it '获取特定报销单的特定状态费用明细' do
      verified_fee_details = service.get_fee_details_by_status('verified', reimbursement.id)
      
      expect(verified_fee_details.count).to eq(1)
      expect(verified_fee_details).to include(@verified_fee_detail)
      expect(verified_fee_details).not_to include(@another_verified_fee_detail)
    end
  end
end
```

## 测试验证方法

1. 运行 `rspec spec/services/fee_detail_verification_service_spec.rb` 确保所有测试通过
2. 在 Rails 控制台中测试服务功能：

```ruby
# 创建测试数据
admin_user = AdminUser.first
reimbursement = Reimbursement.create!(
  invoice_number: 'R20250101001',
  document_name: '测试报销单',
  applicant: '张三',
  applicant_id: 'EMP001',
  company: '测试公司',
  department: '测试部门',
  amount: 1000.00,
  is_complete: false
)

# 创建费用明细
fee_detail1 = FeeDetail.create!(
  document_number: reimbursement.invoice_number,
  fee_type: '交通费',
  amount: 100.0,
  verification_status: 'pending'
)

fee_detail2 = FeeDetail.create!(
  document_number: reimbursement.invoice_number,
  fee_type: '餐饮费',
  amount: 200.0,
  verification_status: 'pending'
)

# 创建审核工单
audit_work_order = AuditWorkOrder.create!(
  reimbursement: reimbursement,
  status: 'auditing',
  created_by: admin_user.id
)

# 关联费用明细到审核工单
selection1 = FeeDetailSelection.create!(
  fee_detail: fee_detail1,
  audit_work_order: audit_work_order,
  verification_status: 'pending'
)

selection2 = FeeDetailSelection.create!(
  fee_detail: fee_detail2,
  audit_work_order: audit_work_order,
  verification_status: 'pending'
)

# 创建服务实例
service = FeeDetailVerificationService.new(admin_user)

# 测试更新单个费用明细验证状态
puts "初始状态: #{fee_detail1.verification_status}"
service.update_verification_status(fee_detail1, 'verified', '验证通过')
puts "更新后状态: #{fee_detail1.reload.verification_status}"
puts "选择记录状态: #{selection1.reload.verification_status}"
puts "选择记录验证意见: #{selection1.verification_comment}"
puts "选择记录验证人: #{selection1.verified_by}"
puts "选择记录验证时间: #{selection1.verified_at}"

# 测试批量验证
result = service.verify_fee_details([fee_detail2.id], 'rejected', '批量拒绝')
puts "批量验证结果: #{result.inspect}"
puts "费用明细2状态: #{fee_detail2.reload.verification_status}"
puts "选择记录2状态: #{selection2.reload.verification_status}"

# 测试在工单中验证费用明细
fee_detail3 = FeeDetail.create!(
  document_number: reimbursement.invoice_number,
  fee_type: '住宿费',
  amount: 300.0,
  verification_status: 'pending'
)

selection3 = FeeDetailSelection.create!(
  fee_detail: fee_detail3,
  audit_work_order: audit_work_order,
  verification_status: 'pending'
)

service.verify_fee_detail_in_work_order(audit_work_order, fee_detail3.id, 'problematic', '金额有问题')
puts "费用明细3状态: #{fee_detail3.reload.verification_status}"
puts "选择记录3状态: #{selection3.reload.verification_status}"
puts "选择记录3验证意见: #{selection3.verification_comment}"

# 测试获取验证历史
history = service.get_verification_history(fee_detail1)
puts "验证历史记录数: #{history.count}"
history.each do |record|
  puts "  状态: #{record.verification_status}, 意见: #{record.verification_comment}, 时间: #{record.verified_at}"
end

# 测试获取特定状态的费用明细
verified_fee_details = service.get_fee_details_by_status('verified')
puts "已验证的费用明细数量: #{verified_fee_details.count}"
rejected_fee_details = service.get_fee_details_by_status('rejected')
puts "已拒绝的费用明细数量: #{rejected_fee_details.count}"
problematic_fee_details = service.get_fee_details_by_status('problematic')
puts "有问题的费用明细数量: #{problematic_fee_details.count}"

# 测试报销单关闭后无法修改费用明细状态
reimbursement.update(is_complete: true)
result = service.update_verification_status(fee_detail1, 'rejected', '报销单已关闭')
puts "报销单关闭后更新结果: #{result}"
puts "错误信息: #{fee_detail1.errors.full_messages.join(', ')}"
puts "费用明细1状态: #{fee_detail1.reload.verification_status}" # 应该仍然是 'verified'
```

## 注意事项

1. 确保验证状态更新逻辑正确实现，特别是关联报销单已关闭的情况
2. 确保费用明细选择记录的更新逻辑正确实现
3. 确保批量验证逻辑正确实现，特别是处理部分失败的情况
4. 确保在工单中验证费用明细的逻辑正确实现
5. 确保错误处理和日志记录功能正确实现
6. 确保测试覆盖所有关键功能，特别是验证状态更新、批量验证和在工单中验证
7. 注意费用明细与费用明细选择记录的关联关系，确保数据一致性
8. 考虑并发操作的情况，可能需要使用事务或锁机制