# 审核工单处理服务实现

## 任务描述

实现审核工单处理服务（AuditWorkOrderService），负责处理审核工单的业务逻辑，包括状态转换、费用明细验证、沟通工单创建等。该服务封装了审核工单的所有操作，提供清晰的接口供控制器调用。

## 输入和依赖

- 基础模型（AuditWorkOrder, FeeDetail, FeeDetailSelection, CommunicationWorkOrder）
- 费用明细验证服务（FeeDetailVerificationService）
- 服务层设计文档 (`docs/refactoring/04_service_implementation.md`)

## 期望输出

完整的审核工单处理服务实现，包括：
- 状态转换方法
- 审核通过和拒绝逻辑
- 费用明细验证逻辑
- 沟通工单创建逻辑
- 完成处理逻辑
- 错误处理和报告
- 单元测试

## 详细实现步骤

### 1. 创建审核工单处理服务

创建 `app/services/audit_work_order_service.rb` 文件：

```ruby
class AuditWorkOrderService
  attr_reader :audit_work_order, :current_admin_user

  def initialize(audit_work_order, current_admin_user)
    @audit_work_order = audit_work_order
    @current_admin_user = current_admin_user
  end

  # 开始处理
  def start_processing
    return false unless @audit_work_order.may_start_processing?
    
    begin
      @audit_work_order.start_processing!
      true
    rescue StateMachines::InvalidTransition => e
      Rails.logger.error "审核工单状态转换错误: #{e.message}"
      false
    end
  end

  # 开始审核
  def start_audit
    return false unless @audit_work_order.may_start_audit?
    
    begin
      @audit_work_order.start_audit!
      true
    rescue StateMachines::InvalidTransition => e
      Rails.logger.error "审核工单状态转换错误: #{e.message}"
      false
    end
  end

  # 审核通过
  def approve(comment = nil)
    return false unless @audit_work_order.may_approve?
    
    begin
      result = @audit_work_order.approve!
      
      # 更新审核信息
      @audit_work_order.update(audit_comment: comment) if comment.present?
      
      # 更新所有关联的费用明细为已验证
      update_associated_fee_details('verified')
      
      result
    rescue StateMachines::InvalidTransition => e
      Rails.logger.error "审核工单状态转换错误: #{e.message}"
      false
    end
  end

  # 审核拒绝
  def reject(comment = nil)
    return false unless @audit_work_order.may_reject?
    
    begin
      result = @audit_work_order.reject!
      
      # 更新审核信息
      @audit_work_order.update(audit_comment: comment) if comment.present?
      
      # 更新所有关联的费用明细为已拒绝
      update_associated_fee_details('rejected')
      
      result
    rescue StateMachines::InvalidTransition => e
      Rails.logger.error "审核工单状态转换错误: #{e.message}"
      false
    end
  end

  # 需要沟通
  def need_communication
    return false unless @audit_work_order.may_need_communication?
    
    begin
      @audit_work_order.need_communication!
      true
    rescue StateMachines::InvalidTransition => e
      Rails.logger.error "审核工单状态转换错误: #{e.message}"
      false
    end
  end

  # 恢复审核
  def resume_audit
    return false unless @audit_work_order.may_resume_audit?
    
    begin
      @audit_work_order.resume_audit!
      true
    rescue StateMachines::InvalidTransition => e
      Rails.logger.error "审核工单状态转换错误: #{e.message}"
      false
    end
  end

  # 完成
  def complete
    return false unless @audit_work_order.may_complete?
    
    begin
      @audit_work_order.complete!
      true
    rescue StateMachines::InvalidTransition => e
      Rails.logger.error "审核工单状态转换错误: #{e.message}"
      false
    end
  end

  # 创建沟通工单
  def create_communication_work_order(params)
    # 确保处于可创建沟通的状态
    return nil unless @audit_work_order.may_need_communication?
    
    # 调用模型方法创建沟通工单并更新自身状态
    communication_work_order = @audit_work_order.create_communication_work_order(params.merge(created_by: @current_admin_user.id))
    
    # 添加初始沟通记录
    if communication_work_order.persisted? && params[:content].present?
      communication_work_order.add_communication_record(
        content: params[:content],
        communicator_role: params[:initiator_role] || 'auditor',
        communicator_name: @current_admin_user.email,
        communication_method: params[:communication_method] || 'system',
        recorded_at: Time.current
      )
    end
    
    communication_work_order
  end

  # 选择费用明细
  def select_fee_details(fee_detail_ids)
    @audit_work_order.select_fee_details(fee_detail_ids)
  end

  # 验证费用明细
  def verify_fee_detail(fee_detail_id, result, comment = nil)
    fee_detail = FeeDetail.find(fee_detail_id)
    
    # 使用 FeeDetailVerificationService 进行验证，确保检查报销单状态
    verification_service = FeeDetailVerificationService.new(@current_admin_user)
    verification_service.update_verification_status(fee_detail, result, comment)
  end

  private

  # 更新关联的费用明细状态
  def update_associated_fee_details(final_status)
    verification_service = FeeDetailVerificationService.new(@current_admin_user)
    
    @audit_work_order.fee_details.each do |fee_detail|
      # 只更新未最终确定的费用明细
      unless ['verified', 'rejected'].include?(fee_detail.verification_status)
        verification_service.update_verification_status(fee_detail, final_status)
      end
    end
  end
end
```

### 2. 创建审核工单处理服务测试

创建 `spec/services/audit_work_order_service_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe AuditWorkOrderService, type: :service do
  let(:admin_user) { create(:admin_user) }
  let(:reimbursement) { create(:reimbursement) }
  let(:fee_detail) { create(:fee_detail, document_number: reimbursement.invoice_number) }
  
  describe '状态转换方法' do
    context '开始处理' do
      let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement, status: 'pending') }
      let(:service) { AuditWorkOrderService.new(audit_work_order, admin_user) }
      
      it '成功转换状态' do
        expect(service.start_processing).to be_truthy
        expect(audit_work_order.reload.status).to eq('processing')
      end
      
      it '处理无效状态转换' do
        audit_work_order.update(status: 'auditing')
        expect(service.start_processing).to be_falsey
      end
    end
    
    context '开始审核' do
      let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement, status: 'processing') }
      let(:service) { AuditWorkOrderService.new(audit_work_order, admin_user) }
      
      it '成功转换状态' do
        expect(service.start_audit).to be_truthy
        expect(audit_work_order.reload.status).to eq('auditing')
      end
      
      it '处理无效状态转换' do
        audit_work_order.update(status: 'pending')
        expect(service.start_audit).to be_falsey
      end
    end
    
    context '审核通过' do
      let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement, status: 'auditing') }
      let(:service) { AuditWorkOrderService.new(audit_work_order, admin_user) }
      
      before do
        # 创建关联的费用明细
        audit_work_order.select_fee_detail(fee_detail)
      end
      
      it '成功转换状态' do
        expect(service.approve('审核通过')).to be_truthy
        expect(audit_work_order.reload.status).to eq('approved')
        expect(audit_work_order.audit_result).to eq('approved')
        expect(audit_work_order.audit_comment).to eq('审核通过')
      end
      
      it '更新关联的费用明细状态' do
        service.approve
        expect(fee_detail.reload.verification_status).to eq('verified')
      end
      
      it '处理无效状态转换' do
        audit_work_order.update(status: 'pending')
        expect(service.approve).to be_falsey
      end
    end
    
    context '审核拒绝' do
      let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement, status: 'auditing') }
      let(:service) { AuditWorkOrderService.new(audit_work_order, admin_user) }
      
      before do
        # 创建关联的费用明细
        audit_work_order.select_fee_detail(fee_detail)
      end
      
      it '成功转换状态' do
        expect(service.reject('审核拒绝')).to be_truthy
        expect(audit_work_order.reload.status).to eq('rejected')
        expect(audit_work_order.audit_result).to eq('rejected')
        expect(audit_work_order.audit_comment).to eq('审核拒绝')
      end
      
      it '更新关联的费用明细状态' do
        service.reject
        expect(fee_detail.reload.verification_status).to eq('rejected')
      end
      
      it '处理无效状态转换' do
        audit_work_order.update(status: 'pending')
        expect(service.reject).to be_falsey
      end
    end
    
    context '需要沟通' do
      let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement, status: 'auditing') }
      let(:service) { AuditWorkOrderService.new(audit_work_order, admin_user) }
      
      it '成功转换状态' do
        expect(service.need_communication).to be_truthy
        expect(audit_work_order.reload.status).to eq('needs_communication')
      end
      
      it '处理无效状态转换' do
        audit_work_order.update(status: 'pending')
        expect(service.need_communication).to be_falsey
      end
    end
    
    context '恢复审核' do
      let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement, status: 'needs_communication') }
      let(:service) { AuditWorkOrderService.new(audit_work_order, admin_user) }
      
      it '成功转换状态' do
        expect(service.resume_audit).to be_truthy
        expect(audit_work_order.reload.status).to eq('auditing')
      end
      
      it '处理无效状态转换' do
        audit_work_order.update(status: 'pending')
        expect(service.resume_audit).to be_falsey
      end
    end
    
    context '完成' do
      let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement, status: 'approved') }
      let(:service) { AuditWorkOrderService.new(audit_work_order, admin_user) }
      
      it '成功转换状态' do
        expect(service.complete).to be_truthy
        expect(audit_work_order.reload.status).to eq('completed')
      end
      
      it '处理无效状态转换' do
        audit_work_order.update(status: 'pending')
        expect(service.complete).to be_falsey
      end
    end
  end
  
  describe '创建沟通工单' do
    let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement, status: 'auditing') }
    let(:service) { AuditWorkOrderService.new(audit_work_order, admin_user) }
    
    it '成功创建沟通工单' do
      params = {
        communication_method: 'email',
        initiator_role: 'auditor',
        content: '需要沟通',
        fee_detail_ids: [fee_detail.id]
      }
      
      communication_work_order = service.create_communication_work_order(params)
      
      expect(communication_work_order).to be_persisted
      expect(communication_work_order.status).to eq('open')
      expect(communication_work_order.communication_method).to eq('email')
      expect(communication_work_order.initiator_role).to eq('auditor')
      expect(communication_work_order.reimbursement_id).to eq(reimbursement.id)
      expect(communication_work_order.audit_work_order_id).to eq(audit_work_order.id)
      expect(communication_work_order.created_by).to eq(admin_user.id)
      
      # 检查沟通记录
      expect(communication_work_order.communication_records.count).to eq(1)
      record = communication_work_order.communication_records.first
      expect(record.content).to eq('需要沟通')
      expect(record.communicator_role).to eq('auditor')
      expect(record.communicator_name).to eq(admin_user.email)
      expect(record.communication_method).to eq('email')
      
      # 检查费用明细关联
      expect(communication_work_order.fee_details).to include(fee_detail)
      expect(fee_detail.reload.verification_status).to eq('problematic')
      
      # 检查审核工单状态
      expect(audit_work_order.reload.status).to eq('needs_communication')
    end
    
    it '处理无效状态' do
      audit_work_order.update(status: 'pending')
      
      params = {
        communication_method: 'email',
        initiator_role: 'auditor',
        content: '需要沟通'
      }
      
      communication_work_order = service.create_communication_work_order(params)
      expect(communication_work_order).to be_nil
    end
  end
  
  describe '费用明细操作' do
    let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement, status: 'auditing') }
    let(:service) { AuditWorkOrderService.new(audit_work_order, admin_user) }
    
    describe '#select_fee_details' do
      it '选择多个费用明细' do
        fee_detail1 = create(:fee_detail, document_number: reimbursement.invoice_number)
        fee_detail2 = create(:fee_detail, document_number: reimbursement.invoice_number)
        
        expect {
          service.select_fee_details([fee_detail1.id, fee_detail2.id])
        }.to change(FeeDetailSelection, :count).by(2)
        
        expect(audit_work_order.fee_details).to include(fee_detail1, fee_detail2)
      end
    end
    
    describe '#verify_fee_detail' do
      it '验证费用明细' do
        audit_work_order.select_fee_detail(fee_detail)
        
        # 模拟 FeeDetailVerificationService
        verification_service = instance_double(FeeDetailVerificationService)
        expect(verification_service).to receive(:update_verification_status).with(fee_detail, 'verified', '验证通过')
        expect(FeeDetailVerificationService).to receive(:new).with(admin_user).and_return(verification_service)
        
        service.verify_fee_detail(fee_detail.id, 'verified', '验证通过')
      end
    end
  end
end
```

### 3. 创建费用明细验证服务

由于审核工单处理服务依赖于费用明细验证服务，我们需要先创建这个服务。创建 `app/services/fee_detail_verification_service.rb` 文件：

```ruby
class FeeDetailVerificationService
  def initialize(current_admin_user)
    @current_admin_user = current_admin_user
  end

  # 用于批量更新，可能较少使用
  def verify_fee_details(fee_detail_ids, verification_status, comment = nil)
    results = { success: 0, failure: 0, errors: [] }
    
    FeeDetail.where(id: fee_detail_ids).each do |fee_detail|
      if update_verification_status(fee_detail, verification_status, comment)
        results[:success] += 1
      else
        results[:failure] += 1
        results[:errors] << "费用明细 ##{fee_detail.id} 更新失败: #{fee_detail.errors.full_messages.join(', ')}"
      end
    end
    
    results
  end

  # 主要由 AuditWorkOrderService 调用
  def update_verification_status(fee_detail, verification_status, comment = nil)
    # 检查关联报销单是否已关闭
    if fee_detail.reimbursement&.is_complete?
      fee_detail.errors.add(:base, "关联报销单已关闭，无法修改费用明细状态")
      return false
    end

    # 检查状态是否有效
    valid_statuses = FeeDetail::VERIFICATION_STATUSES # 假设模型中定义了常量数组
    unless valid_statuses.include?(verification_status)
      fee_detail.errors.add(:verification_status, "无效的状态")
      return false
    end

    # 更新 FeeDetail 自身状态
    fee_detail.verification_status = verification_status
    unless fee_detail.save
      # 如果保存失败，直接返回 false
      return false
    end

    # 更新所有关联的 FeeDetailSelection 记录
    fee_detail.fee_detail_selections.each do |selection|
      selection.update(
        verification_status: verification_status,
        verification_comment: comment,
        verified_by: @current_admin_user.id,
        verified_at: Time.current
      )
    end

    true
  end
end
```

## 测试验证方法

1. 运行 `rspec spec/services/audit_work_order_service_spec.rb` 确保所有测试通过
2. 在 Rails 控制台中测试服务功能：

```ruby
# 创建测试数据
admin_user = AdminUser.first
reimbursement = Reimbursement.create!(
  invoice_number: 'R20250101001',
  document_name: '测试报销单',
  applicant: '张三',
  applicant_id: 'EMP001',
  company: '测试公司',
  department: '测试部门',
  amount: 1000.00
)

# 创建费用明细
fee_detail1 = FeeDetail.create!(
  document_number: reimbursement.invoice_number,
  fee_type: '交通费',
  amount: 100.0,
  verification_status: 'pending'
)

fee_detail2 = FeeDetail.create!(
  document_number: reimbursement.invoice_number,
  fee_type: '餐饮费',
  amount: 200.0,
  verification_status: 'pending'
)

# 创建审核工单
audit_work_order = AuditWorkOrder.create!(
  reimbursement: reimbursement,
  status: 'pending',
  created_by: admin_user.id
)

# 创建服务实例
service = AuditWorkOrderService.new(audit_work_order, admin_user)

# 测试状态转换
puts "初始状态: #{audit_work_order.status}"
service.start_processing
puts "开始处理后状态: #{audit_work_order.reload.status}"
service.start_audit
puts "开始审核后状态: #{audit_work_order.reload.status}"

# 测试选择费用明细
service.select_fee_details([fee_detail1.id, fee_detail2.id])
puts "关联的费用明细数量: #{audit_work_order.reload.fee_details.count}"

# 测试验证费用明细
service.verify_fee_detail(fee_detail1.id, 'verified', '验证通过')
puts "费用明细1状态: #{fee_detail1.reload.verification_status}"

# 测试创建沟通工单
communication_work_order = service.create_communication_work_order({
  communication_method: 'email',
  initiator_role: 'auditor',
  content: '需要沟通',
  fee_detail_ids: [fee_detail2.id]
})
puts "沟通工单创建结果: #{communication_work_order.persisted?}"
puts "沟通工单状态: #{communication_work_order.status}"
puts "审核工单状态: #{audit_work_order.reload.status}"
puts "费用明细2状态: #{fee_detail2.reload.verification_status}"

# 测试恢复审核
service.resume_audit
puts "恢复审核后状态: #{audit_work_order.reload.status}"

# 测试审核通过
service.approve('审核通过')
puts "审核通过后状态: #{audit_work_order.reload.status}"
puts "审核结果: #{audit_work_order.audit_result}"
puts "审核意见: #{audit_work_order.audit_comment}"

# 测试完成
service.complete
puts "完成后状态: #{audit_work_order.reload.status}"
```

## 注意事项

1. 确保状态转换逻辑正确实现，特别是复杂的状态转换和回调函数
2. 确保费用明细验证逻辑正确实现，特别是沟通工单解决后状态不自动更新
3. 确保沟通工单创建逻辑正确实现，包括费用明细关联和初始沟通记录创建
4. 确保错误处理和日志记录功能正确实现
5. 确保测试覆盖所有关键功能，特别是状态转换、费用明细验证和沟通工单创建
6. 注意审核工单与费用明细和沟通工单的关联关系，确保数据一致性
7. 考虑并发操作的情况，可能需要使用事务或锁机制