# 快递收单工单处理服务实现

## 任务描述

实现快递收单工单处理服务（ExpressReceiptWorkOrderService），负责处理快递收单工单的业务逻辑，包括状态转换、完成后创建审核工单等。该服务封装了快递收单工单的所有操作，提供清晰的接口供控制器调用。

## 输入和依赖

- 基础模型（ExpressReceiptWorkOrder, AuditWorkOrder, FeeDetail）
- 服务层设计文档 (`docs/refactoring/04_service_implementation.md`)

## 期望输出

完整的快递收单工单处理服务实现，包括：
- 状态转换方法
- 处理逻辑
- 完成逻辑
- 创建审核工单逻辑
- 关联费用明细逻辑
- 错误处理和报告
- 单元测试

## 详细实现步骤

### 1. 创建快递收单工单处理服务

创建 `app/services/express_receipt_work_order_service.rb` 文件：

```ruby
class ExpressReceiptWorkOrderService
  attr_reader :express_receipt_work_order, :current_admin_user

  def initialize(express_receipt_work_order, current_admin_user)
    @express_receipt_work_order = express_receipt_work_order
    @current_admin_user = current_admin_user
  end

  # 处理
  def process
    return false unless @express_receipt_work_order.may_process?
    
    begin
      @express_receipt_work_order.process!
      true
    rescue StateMachines::InvalidTransition => e
      Rails.logger.error "快递收单工单状态转换错误: #{e.message}"
      false
    end
  end

  # 完成
  def complete
    return false unless @express_receipt_work_order.may_complete?
    
    begin
      result = @express_receipt_work_order.complete!
      
      if result
        # 关联报销单的所有费用明细到新创建的审核工单
        associate_fee_details_to_audit_work_order
      end
      
      result
    rescue StateMachines::InvalidTransition => e
      Rails.logger.error "快递收单工单状态转换错误: #{e.message}"
      false
    end
  end

  # 获取关联的审核工单
  def get_audit_work_order
    @express_receipt_work_order.audit_work_order
  end

  # 获取关联的报销单
  def get_reimbursement
    @express_receipt_work_order.reimbursement
  end

  private

  # 关联费用明细到审核工单
  def associate_fee_details_to_audit_work_order
    audit_work_order = @express_receipt_work_order.audit_work_order
    return false unless audit_work_order
    
    reimbursement = @express_receipt_work_order.reimbursement
    
    # 获取报销单的所有费用明细
    fee_details = reimbursement.fee_details
    
    # 关联每个费用明细到审核工单
    fee_details.each do |fee_detail|
      # 确保费用明细未被其他审核工单锁定
      unless FeeDetailSelection.exists?(fee_detail_id: fee_detail.id, audit_work_order_id: audit_work_order.id)
        audit_work_order.select_fee_detail(fee_detail)
      end
    end
    
    true
  end
end
```

### 2. 创建快递收单工单处理服务测试

创建 `spec/services/express_receipt_work_order_service_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe ExpressReceiptWorkOrderService, type: :service do
  let(:admin_user) { create(:admin_user) }
  let(:reimbursement) { create(:reimbursement) }
  let(:fee_detail) { create(:fee_detail, document_number: reimbursement.invoice_number) }
  
  describe '状态转换方法' do
    context '处理' do
      let(:express_receipt_work_order) { create(:express_receipt_work_order, reimbursement: reimbursement, status: 'received') }
      let(:service) { ExpressReceiptWorkOrderService.new(express_receipt_work_order, admin_user) }
      
      it '成功转换状态' do
        expect(service.process).to be_truthy
        expect(express_receipt_work_order.reload.status).to eq('processed')
      end
      
      it '处理无效状态转换' do
        express_receipt_work_order.update(status: 'completed')
        expect(service.process).to be_falsey
      end
    end
    
    context '完成' do
      let(:express_receipt_work_order) { create(:express_receipt_work_order, reimbursement: reimbursement, status: 'processed') }
      let(:service) { ExpressReceiptWorkOrderService.new(express_receipt_work_order, admin_user) }
      
      before do
        # 创建费用明细
        fee_detail
      end
      
      it '成功转换状态' do
        expect(service.complete).to be_truthy
        expect(express_receipt_work_order.reload.status).to eq('completed')
      end
      
      it '创建审核工单' do
        expect {
          service.complete
        }.to change(AuditWorkOrder, :count).by(1)
        
        audit_work_order = AuditWorkOrder.last
        expect(audit_work_order.reimbursement_id).to eq(reimbursement.id)
        expect(audit_work_order.express_receipt_work_order_id).to eq(express_receipt_work_order.id)
        expect(audit_work_order.status).to eq('pending')
      end
      
      it '关联费用明细到审核工单' do
        service.complete
        
        audit_work_order = AuditWorkOrder.last
        expect(audit_work_order.fee_details).to include(fee_detail)
      end
      
      it '处理无效状态转换' do
        express_receipt_work_order.update(status: 'received')
        expect(service.complete).to be_falsey
      end
    end
  end
  
  describe '其他方法' do
    let(:express_receipt_work_order) { create(:express_receipt_work_order, reimbursement: reimbursement, status: 'completed') }
    let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement, express_receipt_work_order: express_receipt_work_order) }
    let(:service) { ExpressReceiptWorkOrderService.new(express_receipt_work_order, admin_user) }
    
    before do
      # 确保审核工单存在
      audit_work_order
    end
    
    describe '#get_audit_work_order' do
      it '获取关联的审核工单' do
        expect(service.get_audit_work_order).to eq(audit_work_order)
      end
    end
    
    describe '#get_reimbursement' do
      it '获取关联的报销单' do
        expect(service.get_reimbursement).to eq(reimbursement)
      end
    end
  end
  
  describe '私有方法' do
    let(:express_receipt_work_order) { create(:express_receipt_work_order, reimbursement: reimbursement, status: 'processed') }
    let(:service) { ExpressReceiptWorkOrderService.new(express_receipt_work_order, admin_user) }
    
    describe '#associate_fee_details_to_audit_work_order' do
      it '关联费用明细到审核工单' do
        # 创建多个费用明细
        fee_detail1 = create(:fee_detail, document_number: reimbursement.invoice_number)
        fee_detail2 = create(:fee_detail, document_number: reimbursement.invoice_number)
        
        # 完成工单，创建审核工单
        service.complete
        
        # 获取创建的审核工单
        audit_work_order = AuditWorkOrder.last
        
        # 验证费用明细已关联
        expect(audit_work_order.fee_details).to include(fee_detail1, fee_detail2)
        expect(audit_work_order.fee_details.count).to eq(2)
      end
      
      it '不重复关联已关联的费用明细' do
        # 创建费用明细
        fee_detail
        
        # 完成工单，创建审核工单
        service.complete
        
        # 获取创建的审核工单
        audit_work_order = AuditWorkOrder.last
        
        # 再次关联费用明细
        expect {
          service.send(:associate_fee_details_to_audit_work_order)
        }.not_to change(FeeDetailSelection, :count)
      end
      
      it '处理没有审核工单的情况' do
        # 创建一个没有审核工单的快递收单工单
        new_express_receipt_work_order = create(:express_receipt_work_order, reimbursement: reimbursement, status: 'received')
        new_service = ExpressReceiptWorkOrderService.new(new_express_receipt_work_order, admin_user)
        
        # 尝试关联费用明细
        expect(new_service.send(:associate_fee_details_to_audit_work_order)).to be_falsey
      end
    end
  end
end
```

## 测试验证方法

1. 运行 `rspec spec/services/express_receipt_work_order_service_spec.rb` 确保所有测试通过
2. 在 Rails 控制台中测试服务功能：

```ruby
# 创建测试数据
admin_user = AdminUser.first
reimbursement = Reimbursement.create!(
  invoice_number: 'R20250101001',
  document_name: '测试报销单',
  applicant: '张三',
  applicant_id: 'EMP001',
  company: '测试公司',
  department: '测试部门',
  amount: 1000.00
)

# 创建费用明细
fee_detail1 = FeeDetail.create!(
  document_number: reimbursement.invoice_number,
  fee_type: '交通费',
  amount: 100.0,
  verification_status: 'pending'
)

fee_detail2 = FeeDetail.create!(
  document_number: reimbursement.invoice_number,
  fee_type: '餐饮费',
  amount: 200.0,
  verification_status: 'pending'
)

# 创建快递收单工单
express_receipt_work_order = ExpressReceiptWorkOrder.create!(
  reimbursement: reimbursement,
  status: 'received',
  tracking_number: 'SF123456789',
  received_at: Time.current,
  courier_name: '顺丰',
  created_by: admin_user.id
)

# 创建服务实例
service = ExpressReceiptWorkOrderService.new(express_receipt_work_order, admin_user)

# 测试状态转换
puts "初始状态: #{express_receipt_work_order.status}"
service.process
puts "处理后状态: #{express_receipt_work_order.reload.status}"

# 测试完成
service.complete
puts "完成后状态: #{express_receipt_work_order.reload.status}"

# 检查审核工单
audit_work_order = service.get_audit_work_order
puts "审核工单创建结果: #{audit_work_order.present?}"
puts "审核工单状态: #{audit_work_order.status}"
puts "审核工单关联的报销单: #{audit_work_order.reimbursement_id == reimbursement.id}"
puts "审核工单关联的快递收单工单: #{audit_work_order.express_receipt_work_order_id == express_receipt_work_order.id}"

# 检查费用明细关联
puts "审核工单关联的费用明细数量: #{audit_work_order.fee_details.count}"
puts "审核工单关联的费用明细类型: #{audit_work_order.fee_details.pluck(:fee_type).join(', ')}"
```

## 注意事项

1. 确保状态转换逻辑正确实现，特别是复杂的状态转换和回调函数
2. 确保完成后创建审核工单的逻辑正确实现
3. 确保费用明细关联逻辑正确实现，特别是不重复关联已关联的费用明细
4. 确保错误处理和日志记录功能正确实现
5. 确保测试覆盖所有关键功能，特别是状态转换、审核工单创建和费用明细关联
6. 注意快递收单工单与审核工单和费用明细的关联关系，确保数据一致性
7. 考虑并发操作的情况，可能需要使用事务或锁机制