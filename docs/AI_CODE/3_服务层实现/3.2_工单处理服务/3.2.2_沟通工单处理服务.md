# 沟通工单处理服务实现

## 任务描述

实现沟通工单处理服务（CommunicationWorkOrderService），负责处理沟通工单的业务逻辑，包括状态转换、沟通记录添加、通知父工单等。该服务封装了沟通工单的所有操作，提供清晰的接口供控制器调用。

## 输入和依赖

- 基础模型（CommunicationWorkOrder, CommunicationRecord, FeeDetail, FeeDetailSelection）
- 服务层设计文档 (`docs/refactoring/04_service_implementation.md`)

## 期望输出

完整的沟通工单处理服务实现，包括：
- 状态转换方法
- 沟通记录添加逻辑
- 解决和未解决逻辑
- 通知父工单逻辑
- 费用明细问题解决逻辑
- 关闭处理逻辑
- 错误处理和报告
- 单元测试

## 详细实现步骤

### 1. 创建沟通工单处理服务

创建 `app/services/communication_work_order_service.rb` 文件：

```ruby
class CommunicationWorkOrderService
  attr_reader :communication_work_order, :current_admin_user

  def initialize(communication_work_order, current_admin_user)
    @communication_work_order = communication_work_order
    @current_admin_user = current_admin_user
  end

  # 开始沟通
  def start_communication
    return false unless @communication_work_order.may_start_communication?
    
    begin
      @communication_work_order.start_communication!
      true
    rescue StateMachines::InvalidTransition => e
      Rails.logger.error "沟通工单状态转换错误: #{e.message}"
      false
    end
  end

  # 解决
  def resolve(resolution_summary = nil)
    return false unless @communication_work_order.may_resolve?
    
    begin
      result = @communication_work_order.resolve!
      
      # 更新解决摘要
      @communication_work_order.update(resolution_summary: resolution_summary) if resolution_summary.present?
      
      result
    rescue StateMachines::InvalidTransition => e
      Rails.logger.error "沟通工单状态转换错误: #{e.message}"
      false
    end
  end

  # 标记为未解决
  def mark_unresolved(resolution_summary = nil)
    return false unless @communication_work_order.may_mark_unresolved?
    
    begin
      result = @communication_work_order.mark_unresolved!
      
      # 更新解决摘要
      @communication_work_order.update(resolution_summary: resolution_summary) if resolution_summary.present?
      
      result
    rescue StateMachines::InvalidTransition => e
      Rails.logger.error "沟通工单状态转换错误: #{e.message}"
      false
    end
  end

  # 关闭
  def close
    return false unless @communication_work_order.may_close?
    
    begin
      @communication_work_order.close!
      true
    rescue StateMachines::InvalidTransition => e
      Rails.logger.error "沟通工单状态转换错误: #{e.message}"
      false
    end
  end

  # 添加沟通记录
  def add_communication_record(params)
    # 确保参数中包含必要的字段
    unless params[:content].present? && params[:communicator_role].present?
      return nil
    end
    
    # 创建沟通记录
    @communication_work_order.add_communication_record(
      params.merge(
        communicator_name: params[:communicator_name] || @current_admin_user.email,
        recorded_at: Time.current
      )
    )
  end

  # 解决费用明细问题
  def resolve_fee_detail_issue(fee_detail_id, resolution)
    fee_detail = FeeDetail.find_by(id: fee_detail_id)
    return false unless fee_detail
    
    # 查找关联的费用明细选择记录
    selection = @communication_work_order.fee_detail_selections.find_by(fee_detail_id: fee_detail_id)
    return false unless selection
    
    # 更新选择记录的验证意见
    selection.update(verification_comment: resolution)
    
    # 注意：这里不会自动更新费用明细的验证状态
    # 费用明细的状态需要在审核工单中手动更新
    
    true
  end

  # 获取沟通记录
  def get_communication_records
    @communication_work_order.communication_records.order(recorded_at: :desc)
  end

  # 获取关联的费用明细
  def get_fee_details
    @communication_work_order.fee_details
  end

  # 获取父审核工单
  def get_parent_audit_work_order
    @communication_work_order.audit_work_order
  end
end
```

### 2. 创建沟通工单处理服务测试

创建 `spec/services/communication_work_order_service_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe CommunicationWorkOrderService, type: :service do
  let(:admin_user) { create(:admin_user) }
  let(:reimbursement) { create(:reimbursement) }
  let(:audit_work_order) { create(:audit_work_order, reimbursement: reimbursement, status: 'needs_communication') }
  let(:fee_detail) { create(:fee_detail, document_number: reimbursement.invoice_number, verification_status: 'problematic') }
  
  describe '状态转换方法' do
    context '开始沟通' do
      let(:communication_work_order) { create(:communication_work_order, reimbursement: reimbursement, audit_work_order: audit_work_order, status: 'open') }
      let(:service) { CommunicationWorkOrderService.new(communication_work_order, admin_user) }
      
      it '成功转换状态' do
        expect(service.start_communication).to be_truthy
        expect(communication_work_order.reload.status).to eq('in_progress')
      end
      
      it '处理无效状态转换' do
        communication_work_order.update(status: 'resolved')
        expect(service.start_communication).to be_falsey
      end
    end
    
    context '解决' do
      let(:communication_work_order) { create(:communication_work_order, reimbursement: reimbursement, audit_work_order: audit_work_order, status: 'in_progress') }
      let(:service) { CommunicationWorkOrderService.new(communication_work_order, admin_user) }
      
      it '成功转换状态' do
        expect(service.resolve('问题已解决')).to be_truthy
        expect(communication_work_order.reload.status).to eq('resolved')
        expect(communication_work_order.resolution_summary).to eq('问题已解决')
      end
      
      it '通知父工单' do
        service.resolve
        expect(audit_work_order.reload.status).to eq('auditing')
      end
      
      it '处理无效状态转换' do
        communication_work_order.update(status: 'open')
        expect(service.resolve).to be_falsey
      end
    end
    
    context '标记为未解决' do
      let(:communication_work_order) { create(:communication_work_order, reimbursement: reimbursement, audit_work_order: audit_work_order, status: 'in_progress') }
      let(:service) { CommunicationWorkOrderService.new(communication_work_order, admin_user) }
      
      it '成功转换状态' do
        expect(service.mark_unresolved('问题无法解决')).to be_truthy
        expect(communication_work_order.reload.status).to eq('unresolved')
        expect(communication_work_order.resolution_summary).to eq('问题无法解决')
      end
      
      it '通知父工单' do
        service.mark_unresolved
        expect(audit_work_order.reload.status).to eq('auditing')
      end
      
      it '处理无效状态转换' do
        communication_work_order.update(status: 'open')
        expect(service.mark_unresolved).to be_falsey
      end
    end
    
    context '关闭' do
      let(:communication_work_order) { create(:communication_work_order, reimbursement: reimbursement, audit_work_order: audit_work_order, status: 'resolved') }
      let(:service) { CommunicationWorkOrderService.new(communication_work_order, admin_user) }
      
      it '成功转换状态' do
        expect(service.close).to be_truthy
        expect(communication_work_order.reload.status).to eq('closed')
      end
      
      it '处理无效状态转换' do
        communication_work_order.update(status: 'open')
        expect(service.close).to be_falsey
      end
    end
  end
  
  describe '沟通记录操作' do
    let(:communication_work_order) { create(:communication_work_order, reimbursement: reimbursement, audit_work_order: audit_work_order, status: 'in_progress') }
    let(:service) { CommunicationWorkOrderService.new(communication_work_order, admin_user) }
    
    describe '#add_communication_record' do
      it '成功添加沟通记录' do
        params = {
          content: '沟通内容',
          communicator_role: 'auditor',
          communication_method: 'email'
        }
        
        record = service.add_communication_record(params)
        
        expect(record).to be_persisted
        expect(record.content).to eq('沟通内容')
        expect(record.communicator_role).to eq('auditor')
        expect(record.communicator_name).to eq(admin_user.email)
        expect(record.communication_method).to eq('email')
        expect(record.recorded_at).to be_present
      end
      
      it '处理缺少必要字段' do
        params = {
          communicator_role: 'auditor',
          communication_method: 'email'
        }
        
        record = service.add_communication_record(params)
        expect(record).to be_nil
      end
    end
    
    describe '#get_communication_records' do
      it '获取沟通记录' do
        # 创建测试沟通记录
        communication_work_order.add_communication_record(
          content: '沟通记录1',
          communicator_role: 'auditor',
          communicator_name: admin_user.email,
          communication_method: 'email',
          recorded_at: 1.day.ago
        )
        
        communication_work_order.add_communication_record(
          content: '沟通记录2',
          communicator_role: 'applicant',
          communicator_name: '张三',
          communication_method: 'phone',
          recorded_at: Time.current
        )
        
        records = service.get_communication_records
        
        expect(records.count).to eq(2)
        expect(records.first.content).to eq('沟通记录2') # 按时间倒序排列
        expect(records.last.content).to eq('沟通记录1')
      end
    end
  end
  
  describe '费用明细操作' do
    let(:communication_work_order) { create(:communication_work_order, reimbursement: reimbursement, audit_work_order: audit_work_order, status: 'in_progress') }
    let(:service) { CommunicationWorkOrderService.new(communication_work_order, admin_user) }
    
    before do
      # 创建费用明细选择记录
      communication_work_order.fee_detail_selections.create(
        fee_detail: fee_detail,
        verification_status: 'problematic'
      )
    end
    
    describe '#resolve_fee_detail_issue' do
      it '成功解决费用明细问题' do
        expect(service.resolve_fee_detail_issue(fee_detail.id, '已确认金额正确')).to be_truthy
        
        # 验证费用明细选择记录已更新
        selection = communication_work_order.fee_detail_selections.find_by(fee_detail_id: fee_detail.id)
        expect(selection.verification_comment).to eq('已确认金额正确')
        
        # 验证费用明细状态未变化
        expect(fee_detail.reload.verification_status).to eq('problematic')
      end
      
      it '处理不存在的费用明细' do
        expect(service.resolve_fee_detail_issue(999, '不存在的费用明细')).to be_falsey
      end
      
      it '处理未关联的费用明细' do
        another_fee_detail = create(:fee_detail, document_number: reimbursement.invoice_number)
        expect(service.resolve_fee_detail_issue(another_fee_detail.id, '未关联的费用明细')).to be_falsey
      end
    end
    
    describe '#get_fee_details' do
      it '获取关联的费用明细' do
        fee_details = service.get_fee_details
        
        expect(fee_details.count).to eq(1)
        expect(fee_details.first.id).to eq(fee_detail.id)
      end
    end
  end
  
  describe '其他方法' do
    let(:communication_work_order) { create(:communication_work_order, reimbursement: reimbursement, audit_work_order: audit_work_order, status: 'in_progress') }
    let(:service) { CommunicationWorkOrderService.new(communication_work_order, admin_user) }
    
    describe '#get_parent_audit_work_order' do
      it '获取父审核工单' do
        parent_work_order = service.get_parent_audit_work_order
        
        expect(parent_work_order).to eq(audit_work_order)
      end
    end
  end
end
```

## 测试验证方法

1. 运行 `rspec spec/services/communication_work_order_service_spec.rb` 确保所有测试通过
2. 在 Rails 控制台中测试服务功能：

```ruby
# 创建测试数据
admin_user = AdminUser.first
reimbursement = Reimbursement.create!(
  invoice_number: 'R20250101001',
  document_name: '测试报销单',
  applicant: '张三',
  applicant_id: 'EMP001',
  company: '测试公司',
  department: '测试部门',
  amount: 1000.00
)

# 创建费用明细
fee_detail = FeeDetail.create!(
  document_number: reimbursement.invoice_number,
  fee_type: '交通费',
  amount: 100.0,
  verification_status: 'problematic'
)

# 创建审核工单
audit_work_order = AuditWorkOrder.create!(
  reimbursement: reimbursement,
  status: 'needs_communication',
  created_by: admin_user.id
)

# 创建沟通工单
communication_work_order = CommunicationWorkOrder.create!(
  reimbursement: reimbursement,
  audit_work_order: audit_work_order,
  status: 'open',
  communication_method: 'email',
  initiator_role: 'auditor',
  created_by: admin_user.id
)

# 关联费用明细
communication_work_order.fee_detail_selections.create!(
  fee_detail: fee_detail,
  verification_status: 'problematic'
)

# 创建服务实例
service = CommunicationWorkOrderService.new(communication_work_order, admin_user)

# 测试状态转换
puts "初始状态: #{communication_work_order.status}"
service.start_communication
puts "开始沟通后状态: #{communication_work_order.reload.status}"

# 测试添加沟通记录
record = service.add_communication_record({
  content: '已与申请人沟通',
  communicator_role: 'auditor',
  communication_method: 'email'
})
puts "沟通记录创建结果: #{record.persisted?}"
puts "沟通记录内容: #{record.content}"
puts "沟通记录人: #{record.communicator_name}"

# 测试解决费用明细问题
service.resolve_fee_detail_issue(fee_detail.id, '已确认金额正确')
selection = communication_work_order.fee_detail_selections.find_by(fee_detail_id: fee_detail.id)
puts "费用明细选择验证意见: #{selection.verification_comment}"
puts "费用明细状态: #{fee_detail.reload.verification_status}" # 应该仍然是 'problematic'

# 测试解决
service.resolve('问题已解决')
puts "解决后状态: #{communication_work_order.reload.status}"
puts "解决摘要: #{communication_work_order.resolution_summary}"
puts "审核工单状态: #{audit_work_order.reload.status}" # 应该变为 'auditing'

# 测试关闭
service.close
puts "关闭后状态: #{communication_work_order.reload.status}"
```

## 注意事项

1. 确保状态转换逻辑正确实现，特别是复杂的状态转换和回调函数
2. 确保沟通记录添加逻辑正确实现，包括必要字段的验证
3. 确保费用明细问题解决逻辑正确实现，特别是不自动更新费用明细状态
4. 确保通知父工单逻辑正确实现，特别是在解决和未解决状态转换后
5. 确保错误处理和日志记录功能正确实现
6. 确保测试覆盖所有关键功能，特别是状态转换、沟通记录添加和费用明细问题解决
7. 注意沟通工单与审核工单和费用明细的关联关系，确保数据一致性
8. 考虑并发操作的情况，可能需要使用事务或锁机制