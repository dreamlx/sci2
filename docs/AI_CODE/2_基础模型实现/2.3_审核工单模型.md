# 审核工单模型实现

## 任务描述

实现审核工单（AuditWorkOrder）模型，作为工单系统的核心工单类型之一。审核工单负责审核报销单和费用明细，可以创建沟通工单，是整个工单系统的核心业务流程。

## 输入和依赖

- 数据库迁移脚本（已创建的审核工单表）
- 报销单模型（Reimbursement）
- 快递收单工单模型（ExpressReceiptWorkOrder）
- 模型实现设计文档 (`docs/refactoring/03_model_implementation.md`)

## 期望输出

完整的审核工单模型实现，包括：
- 模型属性和验证
- 与报销单和快递收单工单的关联关系
- 复杂状态机实现
- 状态变更记录功能
- 创建沟通工单的功能
- 费用明细验证功能
- ActiveAdmin 配置

## 详细实现步骤

### 1. 创建审核工单模型

创建 `app/models/audit_work_order.rb` 文件：

```ruby
class AuditWorkOrder < ApplicationRecord
  # 关联
  belongs_to :reimbursement
  belongs_to :express_receipt_work_order, optional: true
  has_many :communication_work_orders, dependent: :nullify
  has_many :fee_detail_selections, dependent: :destroy
  has_many :fee_details, through: :fee_detail_selections
  has_many :work_order_status_changes, as: :work_order, dependent: :destroy

  # 验证
  validates :status, presence: true
  validates :audit_result, presence: true, if: -> { %w[approved rejected].include?(status) }
  validates :reimbursement_id, presence: true

  # 回调
  after_save :record_status_change, if: :saved_change_to_status?

  # 状态机
  state_machine :status, initial: :pending do
    # 定义状态
    state :pending, :processing, :auditing, :approved, :rejected, :needs_communication, :completed

    # 定义事件
    event :start_processing do
      transition pending: :processing
    end

    event :start_audit do
      transition processing: :auditing
    end

    event :approve do
      transition auditing: :approved
      after do
        update(
          audit_result: 'approved',
          audit_date: Time.current
        )
      end
    end

    event :reject do
      transition [:auditing, :needs_communication] => :rejected
      after do
        update(
          audit_result: 'rejected',
          audit_date: Time.current
        )
      end
    end

    event :need_communication do
      transition auditing: :needs_communication
# 方法
  def create_communication_work_order(params = {})
    comm_order = CommunicationWorkOrder.new(
      reimbursement: reimbursement,
      audit_work_order: self,
      status: 'open',
      created_by: created_by,
      **params.except(:fee_detail_ids, :content)
    )

    if comm_order.save
      # 如果指定了费用明细ID，则关联这些费用明细
      if params[:fee_detail_ids].present?
        params[:fee_detail_ids].each do |id|
          fee_detail = FeeDetail.find_by(id: id)
          if fee_detail
            # 创建费用明细选择记录
            comm_order.fee_detail_selections.create(
              fee_detail: fee_detail,
              verification_status: 'problematic'
            )

            # 更新费用明细状态
            fee_detail.update(verification_status: 'problematic')
          end
        end
      end

      # 更新自身状态
      need_communication unless status == 'needs_communication'
    end

    comm_order
  end

  def verify_fee_detail(fee_detail, result = 'verified', comment = nil)
    selection = fee_detail_selections.find_by(fee_detail: fee_detail)
    return false unless selection

    selection.update(
      verification_status: result,
      verification_comment: comment,
      verified_by: Current.admin_user&.id,
      verified_at: Time.current
    )

    # 同时更新费用明细的状态
    case result
    when 'verified'
      fee_detail.update(verification_status: 'verified')
    when 'rejected'
      fee_detail.update(verification_status: 'rejected')
    when 'problematic'
      fee_detail.update(verification_status: 'problematic')
    end

    true
  end

  def select_fee_detail(fee_detail)
    fee_detail_selections.find_or_create_by(fee_detail: fee_detail) do |selection|
      selection.verification_status = 'pending'
    end
  end

  def select_fee_details(fee_detail_ids)
    fee_detail_ids.each do |id|
      fee_detail = FeeDetail.find_by(id: id)
      select_fee_detail(fee_detail) if fee_detail
    end
  end

  # 获取状态变更历史
  def status_changes
    work_order_status_changes.order(changed_at: :desc)
  end

  # 获取未解决的沟通工单
  def pending_communication_work_orders
    communication_work_orders.where.not(status: ['resolved', 'unresolved', 'closed'])
  end

  # 检查是否所有费用明细都已验证
  def all_fees_verified?
    fee_detail_selections.where.not(verification_status: ['verified', 'rejected']).count.zero?
  end

  private

  # 记录状态变更
  def record_status_change
    if saved_change_to_status?
      old_status, new_status = saved_change_to_status
      work_order_status_changes.create(
        work_order_type: 'audit',
        from_status: old_status,
        to_status: new_status,
        changed_at: Time.current,
        changed_by: Current.admin_user&.id
      )
    end
  end

  # ActiveAdmin配置
  def self.ransackable_attributes(auth_object = nil)
    %w[id reimbursement_id express_receipt_work_order_id status audit_result audit_comment audit_date vat_verified created_by created_at updated_at]
  end

  def self.ransackable_associations(auth_object = nil)
    %w[reimbursement express_receipt_work_order communication_work_orders fee_detail_selections fee_details work_order_status_changes]
  end
end
```

### 2. 创建审核工单工厂

创建 `spec/factories/audit_work_orders.rb` 文件：

```ruby
FactoryBot.define do
  factory :audit_work_order do
    association :reimbursement
    association :express_receipt_work_order, factory: :express_receipt_work_order, strategy: :build, optional: true
    status { 'pending' }
    created_by { 1 }

    trait :processing do
      status { 'processing' }
    end

    trait :auditing do
      status { 'auditing' }
    end

    trait :approved do
      status { 'approved' }
      audit_result { 'approved' }
      audit_date { Time.current }
    end

    trait :rejected do
      status { 'rejected' }
      audit_result { 'rejected' }
      audit_date { Time.current }
    end

    trait :needs_communication do
      status { 'needs_communication' }
    end

### 3. 创建审核工单模型测试

创建 `spec/models/audit_work_order_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe AuditWorkOrder, type: :model do
  describe "validations" do
    it { should validate_presence_of(:status) }
    it { should validate_presence_of(:reimbursement_id) }

    context "when status is approved or rejected" do
      it "validates presence of audit_result" do
        audit_work_order = build(:audit_work_order, status: 'approved', audit_result: nil)
        expect(audit_work_order).not_to be_valid
        expect(audit_work_order.errors[:audit_result]).to include("can't be blank")

        audit_work_order = build(:audit_work_order, status: 'rejected', audit_result: nil)
        expect(audit_work_order).not_to be_valid
        expect(audit_work_order.errors[:audit_result]).to include("can't be blank")
      end
    end
  end

  describe "associations" do
    it { should belong_to(:reimbursement) }
    it { should belong_to(:express_receipt_work_order).optional }
    it { should have_many(:communication_work_orders).dependent(:nullify) }
    it { should have_many(:fee_detail_selections).dependent(:destroy) }
    it { should have_many(:fee_details).through(:fee_detail_selections) }
    it { should have_many(:work_order_status_changes).dependent(:destroy) }
  end

  describe "state machine" do
    let(:work_order) { create(:audit_work_order) }

    it "has initial state of pending" do
      expect(work_order.status).to eq('pending')
    end

    context "when starting processing" do
      it "can transition from pending to processing" do
        expect(work_order).to be_pending
        expect(work_order.start_processing).to be_truthy
        expect(work_order).to be_processing
      end
    end

    context "when starting audit" do
      before do
        work_order.update(status: 'processing')
      end

      it "can transition from processing to auditing" do
        expect(work_order).to be_processing
        expect(work_order.start_audit).to be_truthy
        expect(work_order).to be_auditing
      end
    end

    context "when approving" do
      before do
        work_order.update(status: 'auditing')
      end

      it "can transition from auditing to approved" do
        expect(work_order).to be_auditing
        expect(work_order.approve).to be_truthy
        expect(work_order).to be_approved
      end

      it "sets audit_result and audit_date after approval" do
        work_order.approve
        expect(work_order.audit_result).to eq('approved')
        expect(work_order.audit_date).not_to be_nil
      end
    end

    context "when rejecting" do
      context "from auditing" do
        before do
          work_order.update(status: 'auditing')
        end

        it "can transition from auditing to rejected" do
          expect(work_order).to be_auditing
          expect(work_order.reject).to be_truthy
          expect(work_order).to be_rejected
        end

        it "sets audit_result and audit_date after rejection" do
          work_order.reject
          expect(work_order.audit_result).to eq('rejected')
          expect(work_order.audit_date).not_to be_nil
        end
      end

      context "from needs_communication" do
        before do
          work_order.update(status: 'needs_communication')
        end

        it "can transition from needs_communication to rejected" do
          expect(work_order).to be_needs_communication
          expect(work_order.reject).to be_truthy
          expect(work_order).to be_rejected
        end
      end
    end

    context "when needing communication" do
      before do
        work_order.update(status: 'auditing')
      end

      it "can transition from auditing to needs_communication" do
        expect(work_order).to be_auditing
        expect(work_order.need_communication).to be_truthy
        expect(work_order).to be_needs_communication
      end
    end

    context "when resuming audit" do
      before do
        work_order.update(status: 'needs_communication')
      end

      it "can transition from needs_communication to auditing" do
        expect(work_order).to be_needs_communication
        expect(work_order.resume_audit).to be_truthy
        expect(work_order).to be_auditing
      end
    end

    context "when completing" do
      context "from approved" do
        before do
          work_order.update(status: 'approved', audit_result: 'approved', audit_date: Time.current)
        end

        it "can transition from approved to completed" do
          expect(work_order).to be_approved
          expect(work_order.complete).to be_truthy
          expect(work_order).to be_completed
        end
      end

      context "from rejected" do
        before do
          work_order.update(status: 'rejected', audit_result: 'rejected', audit_date: Time.current)
        end

        it "can transition from rejected to completed" do
          expect(work_order).to be_rejected
          expect(work_order.complete).to be_truthy
          expect(work_order).to be_completed
        end
      end
    end
  end

  describe "#create_communication_work_order" do
    let(:work_order) { create(:audit_work_order, :auditing) }
    let(:fee_detail) { create(:fee_detail, document_number: work_order.reimbursement.invoice_number) }

    it "creates a communication work order" do
      expect {
        work_order.create_communication_work_order(
          communication_method: "email",
          initiator_role: "auditor"
        )
      }.to change(CommunicationWorkOrder, :count).by(1)
    end

    it "changes status to needs_communication" do
      work_order.create_communication_work_order(
        communication_method: "email",
        initiator_role: "auditor"
      )
      expect(work_order.reload.status).to eq('needs_communication')
    end

    it "associates fee details if provided" do
      comm_order = work_order.create_communication_work_order(
        communication_method: "email",
        initiator_role: "auditor",
        fee_detail_ids: [fee_detail.id]
      )

      expect(comm_order.fee_details).to include(fee_detail)
      expect(fee_detail.reload.verification_status).to eq('problematic')
    end
  end

  describe "#verify_fee_detail" do
    let(:work_order) { create(:audit_work_order, :with_fee_details) }
    let(:fee_detail) { work_order.fee_details.first }

    it "updates fee detail selection verification status" do
      work_order.verify_fee_detail(fee_detail, 'verified', 'Verified OK')
      selection = work_order.fee_detail_selections.find_by(fee_detail: fee_detail)
      
      expect(selection.verification_status).to eq('verified')
      expect(selection.verification_comment).to eq('Verified OK')
      expect(selection.verified_at).not_to be_nil
    end

    it "updates fee detail verification status" do
      work_order.verify_fee_detail(fee_detail, 'verified')
      expect(fee_detail.reload.verification_status).to eq('verified')

      another_fee_detail = work_order.fee_details.second
      work_order.verify_fee_detail(another_fee_detail, 'rejected')
      expect(another_fee_detail.reload.verification_status).to eq('rejected')

      third_fee_detail = work_order.fee_details.third
      work_order.verify_fee_detail(third_fee_detail, 'problematic')
      expect(third_fee_detail.reload.verification_status).to eq('problematic')
    end

    it "returns false if fee detail is not associated with the work order" do
      unrelated_fee_detail = create(:fee_detail)
      expect(work_order.verify_fee_detail(unrelated_fee_detail, 'verified')).to be_falsey
    end
  end

  describe "#select_fee_detail" do
    let(:work_order) { create(:audit_work_order) }
    let(:fee_detail) { create(:fee_detail, document_number: work_order.reimbursement.invoice_number) }

    it "creates a fee detail selection" do
      expect {
        work_order.select_fee_detail(fee_detail)
      }.to change(FeeDetailSelection, :count).by(1)
    end

    it "sets verification status to pending" do
      selection = work_order.select_fee_detail(fee_detail)
      expect(selection.verification_status).to eq('pending')
    end

    it "does not create duplicate selections" do
      work_order.select_fee_detail(fee_detail)
      expect {
        work_order.select_fee_detail(fee_detail)
      }.not_to change(FeeDetailSelection, :count)
    end
  end

  describe "#select_fee_details" do
    let(:work_order) { create(:audit_work_order) }
    let(:fee_details) do
      [
        create(:fee_detail, document_number: work_order.reimbursement.invoice_number),
        create(:fee_detail, document_number: work_order.reimbursement.invoice_number)
      ]
    end

    it "creates multiple fee detail selections" do
      expect {
        work_order.select_fee_details(fee_details.map(&:id))
      }.to change(FeeDetailSelection, :count).by(2)
    end
  end

  describe "status change recording" do
    let(:work_order) { create(:audit_work_order) }

    it "records status change when status changes" do
      expect {
        work_order.start_processing
      }.to change(WorkOrderStatusChange, :count).by(1)

      status_change = WorkOrderStatusChange.last
      expect(status_change.work_order_type).to eq('audit')
      expect(status_change.work_order_id).to eq(work_order.id)
      expect(status_change.from_status).to eq('pending')
      expect(status_change.to_status).to eq('processing')
    end
  end

  describe "#all_fees_verified?" do
    let(:work_order) { create(:audit_work_order, :with_fee_details) }

    it "returns false when not all fees are verified or rejected" do
      expect(work_order.all_fees_verified?).to be_falsey
    end

    it "returns true when all fees are verified or rejected" do
      work_order.fee_details.each_with_index do |fee_detail, index|
        status = index.even? ? 'verified' : 'rejected'
        work_order.verify_fee_detail(fee_detail, status)
      end
      expect(work_order.all_fees_verified?).to be_truthy
    end
  end
end
```
    trait :completed do
      status { 'completed' }
      audit_result { 'approved' }
      audit_date { Time.current }
    end

    trait :with_fee_details do
      transient do
        fee_details_count { 3 }
      end

      after(:create) do |audit_work_order, evaluator|
        create_list(:fee_detail, evaluator.fee_details_count, document_number: audit_work_order.reimbursement.invoice_number).each do |fee_detail|
          audit_work_order.select_fee_detail(fee_detail)
        end
      end
    end
  end
end
```
    end

    event :resume_audit do
      transition needs_communication: :auditing
    end

    event :complete do
      transition [:approved, :rejected] => :completed
    end

    # 状态转换前的回调
    before_transition any => any do |work_order, transition|
      # 可以在这里添加额外的验证逻辑
    end
  end
### 4. 创建 ActiveAdmin 资源

创建 `app/admin/audit_work_orders.rb` 文件（如果尚未创建）：

```ruby
ActiveAdmin.register AuditWorkOrder do
  # 权限控制
  permit_params :reimbursement_id, :express_receipt_work_order_id, :status, :audit_result,
                :audit_comment, :audit_date, :vat_verified, :created_by

  # 菜单设置
  menu priority: 3, label: "审核工单"

  # 过滤器
  filter :reimbursement_invoice_number, as: :string, label: '报销单号'
  filter :status, as: :select, collection: AuditWorkOrder.state_machines[:status].states.map(&:name)
  filter :audit_result, as: :select, collection: ["approved", "rejected"]
  filter :audit_date
  filter :created_at

  # 批量操作
  batch_action :start_processing, if: proc { params[:scope] == 'pending' || params[:q].blank? } do |ids|
    batch_action_collection.find(ids).each do |work_order|
      begin
        work_order.start_processing
      rescue StateMachines::InvalidTransition => e
        Rails.logger.warn "批量处理审核工单 ##{work_order.id} 失败: #{e.message}"
      end
    end
    redirect_to collection_path, notice: "已尝试将选中的工单标记为处理中"
  end

  # 自定义操作
  action_item :start_processing, only: :show, if: proc { resource.status == 'pending' } do
    link_to "开始处理", start_processing_admin_audit_work_order_path(resource), method: :put
  end

  action_item :start_audit, only: :show, if: proc { resource.status == 'processing' } do
    link_to "开始审核", start_audit_admin_audit_work_order_path(resource), method: :put
  end

  action_item :approve, only: :show, if: proc { resource.status == 'auditing' } do
    link_to "审核通过", approve_admin_audit_work_order_path(resource)
  end

  action_item :reject, only: :show, if: proc { ['auditing', 'needs_communication'].include?(resource.status) } do
    link_to "审核拒绝", reject_admin_audit_work_order_path(resource)
  end

  action_item :need_communication, only: :show, if: proc { resource.status == 'auditing' } do
    link_to "需要沟通", new_communication_admin_audit_work_order_path(resource)
  end

  action_item :complete, only: :show, if: proc { ['approved', 'rejected'].include?(resource.status) } do
    link_to "完成", complete_admin_audit_work_order_path(resource), method: :put
  end

  # 自定义页面
  member_action :start_processing, method: :put do
    begin
      resource.start_processing
      redirect_to admin_audit_work_order_path(resource), notice: "工单已开始处理"
    rescue StateMachines::InvalidTransition => e
      redirect_to admin_audit_work_order_path(resource), alert: "状态转换失败: #{e.message}"
    end
  end

  member_action :start_audit, method: :put do
    begin
      resource.start_audit
      redirect_to admin_audit_work_order_path(resource), notice: "工单已开始审核"
    rescue StateMachines::InvalidTransition => e
      redirect_to admin_audit_work_order_path(resource), alert: "状态转换失败: #{e.message}"
    end
  end

  member_action :approve, method: :get do
    render :approve
  end

  member_action :do_approve, method: :post do
    begin
      resource.approve
      resource.update(audit_comment: params[:audit_comment])
      redirect_to admin_audit_work_order_path(resource), notice: "审核已通过"
    rescue StateMachines::InvalidTransition => e
      redirect_to admin_audit_work_order_path(resource), alert: "状态转换失败: #{e.message}"
    end
  end

  member_action :reject, method: :get do
    render :reject
  end

  member_action :do_reject, method: :post do
    begin
      resource.reject
      resource.update(audit_comment: params[:audit_comment])
      redirect_to admin_audit_work_order_path(resource), notice: "审核已拒绝"
    rescue StateMachines::InvalidTransition => e
      redirect_to admin_audit_work_order_path(resource), alert: "状态转换失败: #{e.message}"
    end
  end

  member_action :new_communication, method: :get do
    @fee_details = resource.reimbursement.fee_details.where(verification_status: ['pending', 'problematic'])
    render :new_communication
  end

  member_action :create_communication, method: :post do
    communication_work_order = resource.create_communication_work_order(
      communication_method: params[:communication_method],
      initiator_role: params[:initiator_role],
      content: params[:content],
      fee_detail_ids: params[:fee_detail_ids]
    )

    if communication_work_order.persisted?
      redirect_to admin_communication_work_order_path(communication_work_order), notice: "沟通工单已创建"
    else
      @fee_details = resource.reimbursement.fee_details.where(verification_status: ['pending', 'problematic'])
      render :new_communication, alert: "创建沟通工单失败"
    end
  end

  member_action :complete, method: :put do
    begin
      resource.complete
      redirect_to admin_audit_work_order_path(resource), notice: "工单已完成"
    rescue StateMachines::InvalidTransition => e
      redirect_to admin_audit_work_order_path(resource), alert: "状态转换失败: #{e.message}"
    end
  end

  member_action :verify_fee_detail, method: :get do
    @fee_detail = FeeDetail.find(params[:fee_detail_id])
    render :verify_fee_detail
  end

  member_action :do_verify_fee_detail, method: :post do
    fee_detail = FeeDetail.find(params[:fee_detail_id])
    if resource.verify_fee_detail(fee_detail, params[:verification_status], params[:verification_comment])
      redirect_to admin_audit_work_order_path(resource), notice: "费用明细 ##{params[:fee_detail_id]} 状态已更新"
    else
      @fee_detail = fee_detail
      render :verify_fee_detail, alert: "费用明细 ##{params[:fee_detail_id]} 更新失败"
    end
  end

  # 列表页
  index do
    selectable_column
    id_column
    column :reimbursement do |work_order|
      link_to work_order.reimbursement.invoice_number, admin_reimbursement_path(work_order.reimbursement)
    end
    column :status do |work_order|
      status_tag work_order.status
    end
    column :audit_result do |work_order|
      status_tag work_order.audit_result if work_order.audit_result.present?
    end
    column :audit_date
    column :created_at
    actions
  end

  # 详情页
  show do
    tabs do
      tab "基本信息" do
        attributes_table do
          row :id
          row :reimbursement do |work_order|
            link_to work_order.reimbursement.invoice_number, admin_reimbursement_path(work_order.reimbursement)
          end
          row :express_receipt_work_order do |work_order|
            if work_order.express_receipt_work_order.present?
              link_to work_order.express_receipt_work_order.id, admin_express_receipt_work_order_path(work_order.express_receipt_work_order)
            end
          end
          row :status do |work_order|
            status_tag work_order.status
          end
          row :audit_result do |work_order|
            status_tag work_order.audit_result if work_order.audit_result.present?
          end
          row :audit_comment
          row :audit_date
          row :vat_verified
          row :created_by
          row :created_at
          row :updated_at
        end
      end

      tab "费用明细" do
        panel "费用明细信息" do
          table_for resource.fee_detail_selections.includes(:fee_detail) do
            column "费用明细ID", :fee_detail_id do |sel|
              link_to sel.fee_detail_id, admin_fee_detail_path(sel.fee_detail)
            end
            column "费用类型", :fee_type do |sel|
              sel.fee_detail.fee_type
            end
            column "金额", :amount do |sel|
              number_to_currency(sel.fee_detail.amount, unit: "¥")
            end
            column "验证状态 (工单内)", :verification_status do |sel|
              status_tag sel.verification_status
            end
            column "验证状态 (全局)", :global_status do |sel|
              status_tag sel.fee_detail.verification_status
            end
            column "验证意见", :verification_comment
            column "操作" do |sel|
              links = []
              links << link_to("更新验证状态", verify_fee_detail_admin_audit_work_order_path(resource, fee_detail_id: sel.fee_detail_id))
              if resource.status == 'auditing' && sel.verification_status != 'verified' && sel.verification_status != 'rejected'
                links << link_to("创建沟通工单", new_communication_admin_audit_work_order_path(resource, fee_detail_ids: [sel.fee_detail_id]))
              end
              links.join(" | ").html_safe
            end
          end
        end
      end

      tab "沟通工单" do
        panel "沟通工单信息" do
          table_for resource.communication_work_orders do
            column :id do |comm_wo|
              link_to comm_wo.id, admin_communication_work_order_path(comm_wo)
            end
            column :status do |comm_wo|
              status_tag comm_wo.status
            end
            column :communication_method
            column :initiator_role
            column :created_at
          end
        end
      end

      tab "状态变更历史" do
        panel "状态变更历史" do
          table_for resource.status_changes do
            column :from_status
            column :to_status
            column :changed_at
            column :changed_by do |change|
              AdminUser.find_by(id: change.changed_by)&.email
            end
          end
        end
      end
    end
  end

  # 表单
  form do |f|
    f.inputs "审核工单信息" do
      f.input :reimbursement_id, as: :select, collection: Reimbursement.all.map { |r| [r.invoice_number, r.id] }
      f.input :express_receipt_work_order_id, as: :select, collection: ExpressReceiptWorkOrder.all.map { |w| [w.id, w.id] }
      f.input :status, as: :select, collection: AuditWorkOrder.state_machines[:status].states.map(&:name)
      f.input :audit_result, as: :select, collection: ["approved", "rejected"]
      f.input :audit_comment
      f.input :audit_date, as: :datepicker
      f.input :vat_verified
      f.input :created_by, input_html: { value: current_admin_user.id }, as: :hidden
    end
    f.actions
  end
end
```

## 测试验证方法

1. 运行 `rspec spec/models/audit_work_order_spec.rb` 确保所有测试通过
2. 在 Rails 控制台中测试模型功能：

```ruby
# 创建报销单
reimbursement = Reimbursement.create!(
  invoice_number: "R20250101001",
  document_name: "测试报销单",
  applicant: "张三",
  applicant_id: "EMP001",
  company: "测试公司",
  department: "测试部门",
  amount: 1000.00
)

# 创建费用明细
fee_detail = FeeDetail.create!(
  document_number: reimbursement.invoice_number,
  fee_type: "交通费",
  amount: 150.0,
  verification_status: "pending"
)

# 创建审核工单
work_order = AuditWorkOrder.create!(
  reimbursement: reimbursement,
  status: 'pending',
  created_by: 1
)

# 关联费用明细
work_order.select_fee_detail(fee_detail)

# 测试状态转换
puts "初始状态: #{work_order.status}"
work_order.start_processing
puts "处理后状态: #{work_order.status}"
work_order.start_audit
puts "审核中状态: #{work_order.status}"

# 测试验证费用明细
work_order.verify_fee_detail(fee_detail, 'verified', '验证通过')
puts "费用明细验证状态: #{fee_detail.reload.verification_status}"

# 测试创建沟通工单
comm_order = work_order.create_communication_work_order(
  communication_method: "email",
  initiator_role: "auditor",
  fee_detail_ids: [fee_detail.id]
)
puts "沟通工单状态: #{comm_order.status}"
puts "审核工单状态: #{work_order.reload.status}"

# 测试沟通后恢复审核
work_order.resume_audit
puts "恢复审核后状态: #{work_order.status}"

# 测试审核通过
work_order.approve
puts "审核通过后状态: #{work_order.status}, 审核结果: #{work_order.audit_result}"

# 测试完成
work_order.complete
puts "完成后状态: #{work_order.status}"

# 检查状态变更记录
status_changes = work_order.status_changes
puts "状态变更记录数: #{status_changes.count}"
status_changes.each do |change|
  puts "从 #{change.from_status} 到 #{change.to_status} 于 #{change.changed_at}"
end
```

3. 启动 Rails 服务器，访问 ActiveAdmin 界面，测试审核工单管理功能

## 注意事项

1. 确保状态机正确实现，特别是复杂的状态转换和回调函数
2. 确保状态变更记录功能正确实现
3. 确保创建沟通工单的功能正确实现，特别是关联费用明细和更新状态
4. 确保费用明细验证功能正确实现，特别是同时更新费用明细选择和费用明细的状态
5. 确保与报销单和快递收单工单的关联关系正确设置
6. 确保 ActiveAdmin 配置正确，特别是状态转换操作和费用明细验证界面
7. 注意使用 `state_machines` gem 而不是 AASM，确保语法正确
8. 确保测试覆盖所有关键功能，特别是状态转换、回调函数和业务方法