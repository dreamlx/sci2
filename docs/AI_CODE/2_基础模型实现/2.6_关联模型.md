# 关联模型实现

## 任务描述

实现工单系统中的关联模型，包括费用明细选择（FeeDetailSelection）模型和工单状态变更（WorkOrderStatusChange）模型。这些模型负责处理费用明细与工单的关联关系，以及记录工单状态变更历史。

## 输入和依赖

- 数据库迁移脚本（已创建的费用明细选择表和工单状态变更表）
- 费用明细模型（FeeDetail）
- 审核工单模型（AuditWorkOrder）
- 沟通工单模型（CommunicationWorkOrder）
- 模型实现设计文档 (`docs/refactoring/03_model_implementation.md`)

## 期望输出

完整的关联模型实现，包括：
- 费用明细选择模型的属性和验证
- 工单状态变更模型的属性和验证
- 与其他模型的关联关系
- 必要的业务方法
- ActiveAdmin 配置（如需要）

## 详细实现步骤

### 1. 创建费用明细选择模型

创建 `app/models/fee_detail_selection.rb` 文件：

```ruby
class FeeDetailSelection < ApplicationRecord
  # 常量
  VERIFICATION_STATUS_PENDING = 'pending'
  VERIFICATION_STATUS_VERIFIED = 'verified'
  VERIFICATION_STATUS_REJECTED = 'rejected'
  VERIFICATION_STATUS_PROBLEMATIC = 'problematic'
  
  VERIFICATION_STATUSES = [
    VERIFICATION_STATUS_PENDING,
    VERIFICATION_STATUS_VERIFIED,
    VERIFICATION_STATUS_REJECTED,
    VERIFICATION_STATUS_PROBLEMATIC
  ]

  # 关联
  belongs_to :fee_detail
  belongs_to :audit_work_order, optional: true
  belongs_to :communication_work_order, optional: true

  # 验证
  validates :verification_status, presence: true, inclusion: { in: VERIFICATION_STATUSES }
  validates :fee_detail_id, uniqueness: { scope: :audit_work_order_id }, if: :audit_work_order_id?
  validates :fee_detail_id, uniqueness: { scope: :communication_work_order_id }, if: :communication_work_order_id?
  validate :ensure_one_work_order_association

  # 范围
  scope :pending, -> { where(verification_status: VERIFICATION_STATUS_PENDING) }
  scope :verified, -> { where(verification_status: VERIFICATION_STATUS_VERIFIED) }
  scope :rejected, -> { where(verification_status: VERIFICATION_STATUS_REJECTED) }
  scope :problematic, -> { where(verification_status: VERIFICATION_STATUS_PROBLEMATIC) }
  scope :for_audit_work_orders, -> { where.not(audit_work_order_id: nil) }
  scope :for_communication_work_orders, -> { where.not(communication_work_order_id: nil) }

  # 方法
  def mark_as_verified(comment = nil, verified_by = nil)
    update(
      verification_status: VERIFICATION_STATUS_VERIFIED,
      verification_comment: comment,
      verified_by: verified_by,
      verified_at: Time.current
    )
  end

  def mark_as_rejected(comment = nil, verified_by = nil)
    update(
      verification_status: VERIFICATION_STATUS_REJECTED,
      verification_comment: comment,
      verified_by: verified_by,
      verified_at: Time.current
    )
  end

  def mark_as_problematic(comment = nil, verified_by = nil)
    update(
      verification_status: VERIFICATION_STATUS_PROBLEMATIC,
      verification_comment: comment,
      verified_by: verified_by,
      verified_at: Time.current
    )
  end

  def verified?
    verification_status == VERIFICATION_STATUS_VERIFIED
  end

  def rejected?
    verification_status == VERIFICATION_STATUS_REJECTED
  end

  def problematic?
    verification_status == VERIFICATION_STATUS_PROBLEMATIC
  end

  def pending?
    verification_status == VERIFICATION_STATUS_PENDING
  end

  def work_order
    audit_work_order || communication_work_order
  end

  def work_order_type
    if audit_work_order_id.present?
      'audit'
    elsif communication_work_order_id.present?
      'communication'
    else
      nil
    end
  end

  private

  def ensure_one_work_order_association
    if audit_work_order_id.blank? && communication_work_order_id.blank?
      errors.add(:base, "必须关联到审核工单或沟通工单")
    end

    if audit_work_order_id.present? && communication_work_order_id.present?
      errors.add(:base, "不能同时关联到审核工单和沟通工单")
    end
  end

  # ActiveAdmin配置
  def self.ransackable_attributes(auth_object = nil)
    %w[id fee_detail_id audit_work_order_id communication_work_order_id verification_status verification_comment verified_by verified_at created_at updated_at]
  end

  def self.ransackable_associations(auth_object = nil)
    %w[fee_detail audit_work_order communication_work_order]
  end
end
```

### 2. 创建工单状态变更模型

创建 `app/models/work_order_status_change.rb` 文件：

```ruby
class WorkOrderStatusChange < ApplicationRecord
  # 关联
  belongs_to :work_order, polymorphic: true, optional: true

  # 验证
  validates :work_order_type, presence: true
  validates :work_order_id, presence: true
  validates :to_status, presence: true
  validates :changed_at, presence: true

  # 范围
  scope :for_express_receipt_work_orders, -> { where(work_order_type: 'express_receipt') }
  scope :for_audit_work_orders, -> { where(work_order_type: 'audit') }
  scope :for_communication_work_orders, -> { where(work_order_type: 'communication') }
  scope :recent, -> { order(changed_at: :desc) }
  scope :by_changed_by, ->(user_id) { where(changed_by: user_id) }

  # 方法
  def work_order_object
    case work_order_type
    when 'express_receipt'
      ExpressReceiptWorkOrder.find_by(id: work_order_id)
    when 'audit'
      AuditWorkOrder.find_by(id: work_order_id)
    when 'communication'
      CommunicationWorkOrder.find_by(id: work_order_id)
    end
  end

  def changed_by_user
    AdminUser.find_by(id: changed_by) if changed_by.present?
  end

  def status_change_description
    "从 #{from_status || '(初始状态)'} 变更为 #{to_status}"
  end

  # ActiveAdmin配置
  def self.ransackable_attributes(auth_object = nil)
    %w[id work_order_type work_order_id from_status to_status changed_at changed_by reason created_at updated_at]
  end

  def self.ransackable_associations(auth_object = nil)
    %w[work_order]
  end
end
```

### 3. 创建费用明细选择工厂

创建 `spec/factories/fee_detail_selections.rb` 文件：

```ruby
FactoryBot.define do
  factory :fee_detail_selection do
    association :fee_detail
    verification_status { "pending" }

    trait :for_audit_work_order do
      association :audit_work_order
      communication_work_order_id { nil }
    end

    trait :for_communication_work_order do
      association :communication_work_order
      audit_work_order_id { nil }
    end

    trait :verified do
      verification_status { "verified" }
      verified_at { Time.current }
      verified_by { 1 }
    end

    trait :rejected do
      verification_status { "rejected" }
      verified_at { Time.current }
      verified_by { 1 }
    end

    trait :problematic do
      verification_status { "problematic" }
      verified_at { Time.current }
      verified_by { 1 }
    end

    trait :with_comment do
      verification_comment { "验证备注" }
    end
  end
end
```

### 4. 创建工单状态变更工厂

创建 `spec/factories/work_order_status_changes.rb` 文件：

```ruby
FactoryBot.define do
  factory :work_order_status_change do
    work_order_type { ["express_receipt", "audit", "communication"].sample }
    sequence(:work_order_id) { |n| n }
    from_status { nil }
    to_status { "pending" }
    changed_at { Time.current }
    changed_by { 1 }

    trait :for_express_receipt do
      work_order_type { "express_receipt" }
      association :work_order, factory: :express_receipt_work_order
    end

    trait :for_audit do
      work_order_type { "audit" }
      association :work_order, factory: :audit_work_order
    end

    trait :for_communication do
      work_order_type { "communication" }
      association :work_order, factory: :communication_work_order
    end

    trait :with_reason do
      reason { "状态变更原因" }
    end
  end
end
```

### 5. 创建费用明细选择模型测试

创建 `spec/models/fee_detail_selection_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe FeeDetailSelection, type: :model do
  describe "validations" do
    it { should validate_presence_of(:verification_status) }
    it { should validate_inclusion_of(:verification_status).in_array(FeeDetailSelection::VERIFICATION_STATUSES) }

    context "when associated with audit work order" do
      subject { build(:fee_detail_selection, :for_audit_work_order) }
      it { should validate_uniqueness_of(:fee_detail_id).scoped_to(:audit_work_order_id) }
    end

    context "when associated with communication work order" do
      subject { build(:fee_detail_selection, :for_communication_work_order) }
      it { should validate_uniqueness_of(:fee_detail_id).scoped_to(:communication_work_order_id) }
    end

    it "requires association with either audit or communication work order" do
      selection = build(:fee_detail_selection, audit_work_order_id: nil, communication_work_order_id: nil)
      expect(selection).not_to be_valid
      expect(selection.errors[:base]).to include("必须关联到审核工单或沟通工单")
    end

    it "cannot be associated with both audit and communication work order" do
      selection = build(:fee_detail_selection, :for_audit_work_order)
      selection.communication_work_order = build(:communication_work_order)
      expect(selection).not_to be_valid
      expect(selection.errors[:base]).to include("不能同时关联到审核工单和沟通工单")
    end
  end

  describe "associations" do
    it { should belong_to(:fee_detail) }
    it { should belong_to(:audit_work_order).optional }
    it { should belong_to(:communication_work_order).optional }
  end

  describe "scopes" do
    before do
      create(:fee_detail_selection, :for_audit_work_order, verification_status: 'pending')
      create(:fee_detail_selection, :for_audit_work_order, verification_status: 'verified')
      create(:fee_detail_selection, :for_audit_work_order, verification_status: 'rejected')
      create(:fee_detail_selection, :for_communication_work_order, verification_status: 'problematic')
    end

    it "returns pending selections" do
      expect(FeeDetailSelection.pending.count).to eq(1)
    end

    it "returns verified selections" do
      expect(FeeDetailSelection.verified.count).to eq(1)
    end

    it "returns rejected selections" do
      expect(FeeDetailSelection.rejected.count).to eq(1)
    end

    it "returns problematic selections" do
      expect(FeeDetailSelection.problematic.count).to eq(1)
    end

    it "returns selections for audit work orders" do
      expect(FeeDetailSelection.for_audit_work_orders.count).to eq(3)
    end

    it "returns selections for communication work orders" do
      expect(FeeDetailSelection.for_communication_work_orders.count).to eq(1)
    end
  end

  describe "methods" do
    let(:selection) { create(:fee_detail_selection, :for_audit_work_order) }

    describe "#mark_as_verified" do
      it "updates verification_status to verified" do
        selection.mark_as_verified("验证通过", 1)
        expect(selection.reload.verification_status).to eq('verified')
        expect(selection.verification_comment).to eq('验证通过')
        expect(selection.verified_by).to eq(1)
        expect(selection.verified_at).not_to be_nil
      end
    end

    describe "#mark_as_rejected" do
      it "updates verification_status to rejected" do
        selection.mark_as_rejected("验证拒绝", 1)
        expect(selection.reload.verification_status).to eq('rejected')
        expect(selection.verification_comment).to eq('验证拒绝')
        expect(selection.verified_by).to eq(1)
        expect(selection.verified_at).not_to be_nil
      end
    end

    describe "#mark_as_problematic" do
      it "updates verification_status to problematic" do
        selection.mark_as_problematic("验证有问题", 1)
        expect(selection.reload.verification_status).to eq('problematic')
        expect(selection.verification_comment).to eq('验证有问题')
        expect(selection.verified_by).to eq(1)
        expect(selection.verified_at).not_to be_nil
      end
    end

    describe "status check methods" do
      it "returns true for verified? when status is verified" do
        selection.update(verification_status: 'verified')
        expect(selection.verified?).to be_truthy
      end

      it "returns true for rejected? when status is rejected" do
        selection.update(verification_status: 'rejected')
        expect(selection.rejected?).to be_truthy
      end

      it "returns true for problematic? when status is problematic" do
        selection.update(verification_status: 'problematic')
        expect(selection.problematic?).to be_truthy
      end

      it "returns true for pending? when status is pending" do
        expect(selection.pending?).to be_truthy
      end
    end

    describe "#work_order" do
      it "returns audit work order when associated with audit work order" do
        expect(selection.work_order).to eq(selection.audit_work_order)
      end

      it "returns communication work order when associated with communication work order" do
        selection = create(:fee_detail_selection, :for_communication_work_order)
        expect(selection.work_order).to eq(selection.communication_work_order)
      end
    end

    describe "#work_order_type" do
      it "returns 'audit' when associated with audit work order" do
        expect(selection.work_order_type).to eq('audit')
      end

      it "returns 'communication' when associated with communication work order" do
        selection = create(:fee_detail_selection, :for_communication_work_order)
        expect(selection.work_order_type).to eq('communication')
      end

      it "returns nil when not associated with any work order" do
        selection = build(:fee_detail_selection, audit_work_order_id: nil, communication_work_order_id: nil)
        expect(selection.work_order_type).to be_nil
      end
    end
  end
end
```

### 6. 创建工单状态变更模型测试

创建 `spec/models/work_order_status_change_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe WorkOrderStatusChange, type: :model do
  describe "validations" do
    it { should validate_presence_of(:work_order_type) }
    it { should validate_presence_of(:work_order_id) }
    it { should validate_presence_of(:to_status) }
    it { should validate_presence_of(:changed_at) }
  end

  describe "associations" do
    it { should belong_to(:work_order).optional }
  end

  describe "scopes" do
    before do
      create(:work_order_status_change, work_order_type: 'express_receipt', to_status: 'received')
      create(:work_order_status_change, work_order_type: 'audit', to_status: 'pending')
      create(:work_order_status_change, work_order_type: 'communication', to_status: 'open')
    end

    it "returns changes for express receipt work orders" do
      expect(WorkOrderStatusChange.for_express_receipt_work_orders.count).to eq(1)
    end

    it "returns changes for audit work orders" do
      expect(WorkOrderStatusChange.for_audit_work_orders.count).to eq(1)
    end

    it "returns changes for communication work orders" do
      expect(WorkOrderStatusChange.for_communication_work_orders.count).to eq(1)
    end

    it "returns changes in descending order by changed_at" do
      # Create a change with an earlier time
      create(:work_order_status_change, changed_at: 1.day.ago)
      
      changes = WorkOrderStatusChange.recent
      expect(changes.first.changed_at).to be > changes.last.changed_at
    end

    it "returns changes by changed_by" do
      create(:work_order_status_change, changed_by: 999)
      expect(WorkOrderStatusChange.by_changed_by(999).count).to eq(1)
    end
  end

  describe "methods" do
    describe "#work_order_object" do
      it "returns express receipt work order when work_order_type is 'express_receipt'" do
        work_order = create(:express_receipt_work_order)
        status_change = create(:work_order_status_change, work_order_type: 'express_receipt', work_order_id: work_order.id)
        expect(status_change.work_order_object).to eq(work_order)
      end

      it "returns audit work order when work_order_type is 'audit'" do
        work_order = create(:audit_work_order)
        status_change = create(:work_order_status_change, work_order_type: 'audit', work_order_id: work_order.id)
        expect(status_change.work_order_object).to eq(work_order)
      end

      it "returns communication work order when work_order_type is 'communication'" do
        work_order = create(:communication_work_order)
        status_change = create(:work_order_status_change, work_order_type: 'communication', work_order_id: work_order.id)
        expect(status_change.work_order_object).to eq(work_order)
      end

      it "returns nil when work order does not exist" do
        status_change = create(:work_order_status_change, work_order_type: 'audit', work_order_id: 999999)
        expect(status_change.work_order_object).to be_nil
      end
    end

    describe "#changed_by_user" do
      it "returns admin user when changed_by is present" do
        admin_user = create(:admin_user)
        status_change = create(:work_order_status_change, changed_by: admin_user.id)
        expect(status_change.changed_by_user).to eq(admin_user)
      end

      it "returns nil when changed_by is not present" do
        status_change = create(:work_order_status_change, changed_by: nil)
        expect(status_change.changed_by_user).to be_nil
      end
    end

    describe "#status_change_description" do
      it "returns description with from_status and to_status" do
        status_change = create(:work_order_status_change, from_status: 'pending', to_status: 'processing')
        expect(status_change.status_change_description).to eq("从 pending 变更为 processing")
      end

      it "returns description with '(初始状态)' when from_status is nil" do
        status_change = create(:work_order_status_change, from_status: nil, to_status: 'pending')
        expect(status_change.status_change_description).to eq("从 (初始状态) 变更为 pending")
      end
    end
  end
end
```

## 测试验证方法

1. 运行 `rspec spec/models/fee_detail_selection_spec.rb spec/models/work_order_status_change_spec.rb` 确保所有测试通过
2. 在 Rails 控制台中测试模型功能：

```ruby
# 创建报销单
reimbursement = Reimbursement.create!(
  invoice_number: "R20250101001",
  document_name: "测试报销单",
  applicant: "张三",
  applicant_id: "EMP001",
  company: "测试公司",
  department: "测试部门",
  amount: 1000.00
)

# 创建费用明细
fee_detail = FeeDetail.create!(
  document_number: reimbursement.invoice_number,
  fee_type: "交通费",
  amount: 150.0,
  verification_status: "pending"
)

# 创建审核工单
audit_work_order = AuditWorkOrder.create!(
  reimbursement: reimbursement,
  status: 'pending',
  created_by: 1
)

# 创建费用明细选择
selection = FeeDetailSelection.create!(
  fee_detail: fee_detail,
  audit_work_order: audit_work_order,
  verification_status: 'pending'
)

# 测试费用明细选择方法
puts "初始状态: #{selection.verification_status}"
selection.mark_as_verified("验证通过", 1)
puts "验证后状态: #{selection.verification_status}, 验证备注: #{selection.verification_comment}, 验证人: #{selection.verified_by}, 验证时间: #{selection.verified_at}"
puts "verified?: #{selection.verified?}"

# 测试工单状态变更
audit_work_order.start_processing
status_change = WorkOrderStatusChange.last
puts "工单状态变更: #{status_change.status_change_description}, 变更时间: #{status_change.changed_at}"
puts "工单类型: #{status_change.work_order_type}, 工单ID: #{status_change.work_order_id}"
puts "工单对象: #{status_change.work_order_object.class.name} ##{status_change.work_order_object.id}"
```

## 注意事项

1. 确保费用明细选择模型的验证正确实现，特别是确保一个费用明细在一个工单中只被选择一次
2. 确保工单状态变更模型的关联关系正确设置，特别是多态关联
3. 确保费用明细选择模型的状态更新方法正确实现
4. 确保工单状态变更模型的查询方法正确实现
5. 注意费用明细选择模型必须关联到审核工单或沟通工单，但不能同时关联到两者
6. 确保测试覆盖所有关键功能，特别是验证规则和业务方法