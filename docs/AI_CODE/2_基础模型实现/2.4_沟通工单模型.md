# 沟通工单模型实现

## 任务描述

实现沟通工单（CommunicationWorkOrder）模型，包括定义模型属性和验证、实现与报销单和审核工单的关联关系、使用 AASM 实现状态机、实现状态变更记录功能、实现沟通记录功能以及实现费用明细关联功能。

## 输入和依赖

- 已完成的数据库迁移
- 已实现的报销单模型
- 已实现的审核工单模型
- 数据库结构设计文档 (`docs/refactoring/02_database_structure.md`)
- 模型实现设计文档 (`docs/refactoring/03_model_implementation.md`)

## 期望输出

完整的沟通工单模型实现，包括：
- 模型属性和验证
- 与报销单和审核工单的关联关系
- AASM 状态机实现
- 状态变更记录功能
- 沟通记录功能
- 费用明细关联功能
- ActiveAdmin 配置

## 详细实现步骤

### 1. 创建沟通工单模型

创建 `app/models/communication_work_order.rb` 文件：

```ruby
# app/models/communication_work_order.rb
class CommunicationWorkOrder < ApplicationRecord
  # 关联
  belongs_to :reimbursement
  belongs_to :audit_work_order
  has_many :communication_records, dependent: :destroy
  has_many :fee_detail_selections, dependent: :destroy
  has_many :fee_details, through: :fee_detail_selections
  has_many :work_order_status_changes, as: :work_order, dependent: :destroy
  
  # 验证
  validates :status, presence: true, inclusion: { in: %w[open in_progress resolved unresolved closed] }
  
  # 回调
  after_save :record_status_change, if: :saved_change_to_status?
  
  # 状态机
  include AASM
  
  aasm column: 'status' do
    state :open, initial: true
    state :in_progress
    state :resolved
    state :unresolved
    state :closed
    
    event :start_communication do
      transitions from: :open, to: :in_progress
    end
    
    event :resolve do
      transitions from: :in_progress, to: :resolved
      after do
        notify_parent_work_order
      end
    end
    
    event :mark_unresolved do
      transitions from: :in_progress, to: :unresolved
      after do
        notify_parent_work_order
      end
    end
    
    event :close do
      transitions from: [:resolved, :unresolved], to: :closed
    end
  end
# 方法
  def add_communication_record(params)
    communication_records.create(params)
  end
  
  def notify_parent_work_order
    return unless audit_work_order.present?
    
    if audit_work_order.status == 'needs_communication'
      audit_work_order.resume_audit
    end
  end
  
  def select_fee_detail(fee_detail)
    fee_detail_selections.find_or_create_by(fee_detail: fee_detail) do |selection|
      selection.verification_status = 'problematic'
    end
  end
  
  def resolve_fee_detail_issue(fee_detail, resolution)
    selection = fee_detail_selections.find_by(fee_detail: fee_detail)
    return false unless selection
    
    # 更新选择记录
    selection.update(
      verification_comment: resolution
    )
    
    true
  end
  
  private
  
  def record_status_change
    if saved_change_to_status?
      old_status, new_status = saved_change_to_status
      work_order_status_changes.create(
        work_order_type: 'communication',
        from_status: old_status,
        to_status: new_status,
        changed_at: Time.current,
        changed_by: Current.admin_user&.id
      )
    end
  end
  
  # ActiveAdmin配置
  def self.ransackable_attributes(auth_object = nil)
    %w[id reimbursement_id audit_work_order_id status communication_method initiator_role resolution_summary created_by created_at updated_at]
  end
  
  def self.ransackable_associations(auth_object = nil)
    %w[reimbursement audit_work_order communication_records fee_detail_selections fee_details work_order_status_changes]
  end
end
```

### 2. 创建沟通记录模型

创建 `app/models/communication_record.rb` 文件：

```ruby
# app/models/communication_record.rb
class CommunicationRecord < ApplicationRecord
  # 关联
  belongs_to :communication_work_order
  
  # 验证
  validates :content, presence: true
  validates :communicator_role, presence: true
  
  # 回调
  before_create :set_recorded_at
  
  private
  
  def set_recorded_at
    self.recorded_at ||= Time.current
  end
  
  # ActiveAdmin配置
  def self.ransackable_attributes(auth_object = nil)
    %w[id communication_work_order_id content communicator_role communicator_name communication_method recorded_at created_at updated_at]
  end
  
  def self.ransackable_associations(auth_object = nil)
    %w[communication_work_order]
  end
end
```

### 3. 创建沟通工单工厂（用于测试）

创建 `spec/factories/communication_work_orders.rb` 文件：

```ruby
# spec/factories/communication_work_orders.rb
FactoryBot.define do
  factory :communication_work_order do
    association :reimbursement
    association :audit_work_order
    status { "open" }
    communication_method { ["email", "phone", "system", "other"].sample }
    initiator_role { ["auditor", "applicant", "manager", "other"].sample }
    created_by { 1 }
    
    trait :in_progress do
      status { "in_progress" }
    end
    
    trait :resolved do
      status { "resolved" }
      resolution_summary { "问题已解决" }
    end
    
    trait :unresolved do
      status { "unresolved" }
      resolution_summary { "问题无法解决" }
    end
    
    trait :closed do
      status { "closed" }
    end
    
    trait :with_communication_records do
      after(:create) do |work_order|
        create_list(:communication_record, 2, communication_work_order: work_order)
      end
    end
    
    trait :with_fee_details do
      after(:create) do |work_order|
        fee_detail = create(:fee_detail, document_number: work_order.reimbursement.invoice_number)
        work_order.select_fee_detail(fee_detail)
      end
    end
  end
end
```

### 4. 创建沟通记录工厂（用于测试）

创建 `spec/factories/communication_records.rb` 文件：

```ruby
# spec/factories/communication_records.rb
FactoryBot.define do
  factory :communication_record do
    association :communication_work_order
    content { "这是一条沟通记录内容" }
    communicator_role { ["auditor", "applicant", "manager", "other"].sample }
    communicator_name { "测试用户" }
    communication_method { ["email", "phone", "system", "other"].sample }
    recorded_at { Time.current }
### 5. 创建沟通工单模型测试

创建 `spec/models/communication_work_order_spec.rb` 文件：

```ruby
# spec/models/communication_work_order_spec.rb
require 'rails_helper'

RSpec.describe CommunicationWorkOrder, type: :model do
  describe "validations" do
    it { should validate_presence_of(:status) }
    it { should validate_inclusion_of(:status).in_array(%w[open in_progress resolved unresolved closed]) }
  end
  
  describe "associations" do
    it { should belong_to(:reimbursement) }
    it { should belong_to(:audit_work_order) }
    it { should have_many(:communication_records).dependent(:destroy) }
    it { should have_many(:fee_detail_selections).dependent(:destroy) }
    it { should have_many(:fee_details).through(:fee_detail_selections) }
    it { should have_many(:work_order_status_changes).dependent(:destroy) }
  end
  
  describe "state machine" do
    let(:work_order) { create(:communication_work_order) }
    
    context "when in open state" do
      it "can transition to in_progress" do
        expect(work_order.status).to eq("open")
        expect(work_order).to allow_event(:start_communication)
        expect(work_order).not_to allow_event(:resolve)
        expect(work_order).not_to allow_event(:mark_unresolved)
        expect(work_order).not_to allow_event(:close)
      end
      
      it "changes status to in_progress after start_communication event" do
        work_order.start_communication!
        expect(work_order.status).to eq("in_progress")
      end
    end
    
    context "when in in_progress state" do
      let(:work_order) { create(:communication_work_order, :in_progress) }
      
      it "can transition to resolved or unresolved" do
        expect(work_order.status).to eq("in_progress")
        expect(work_order).to allow_event(:resolve)
        expect(work_order).to allow_event(:mark_unresolved)
        expect(work_order).not_to allow_event(:start_communication)
        expect(work_order).not_to allow_event(:close)
      end
      
      it "changes status to resolved after resolve event" do
        work_order.resolve!
        expect(work_order.status).to eq("resolved")
      end
      
      it "changes status to unresolved after mark_unresolved event" do
        work_order.mark_unresolved!
        expect(work_order.status).to eq("unresolved")
      end
    end
    
    context "when in resolved state" do
      let(:work_order) { create(:communication_work_order, :resolved) }
      
      it "can transition to closed" do
        expect(work_order.status).to eq("resolved")
        expect(work_order).to allow_event(:close)
        expect(work_order).not_to allow_event(:start_communication)
        expect(work_order).not_to allow_event(:resolve)
        expect(work_order).not_to allow_event(:mark_unresolved)
      end
      
      it "changes status to closed after close event" do
        work_order.close!
        expect(work_order.status).to eq("closed")
      end
    end
    
    context "when in unresolved state" do
      let(:work_order) { create(:communication_work_order, :unresolved) }
      
      it "can transition to closed" do
        expect(work_order.status).to eq("unresolved")
        expect(work_order).to allow_event(:close)
        expect(work_order).not_to allow_event(:start_communication)
        expect(work_order).not_to allow_event(:resolve)
        expect(work_order).not_to allow_event(:mark_unresolved)
      end
      
      it "changes status to closed after close event" do
        work_order.close!
        expect(work_order.status).to eq("closed")
      end
    end
  end
  
  describe "callbacks" do
    let(:work_order) { create(:communication_work_order) }
    
    context "when status changes" do
      before do
        allow(Current).to receive(:admin_user).and_return(double(id: 1))
      end
      
      it "records status change" do
        expect { work_order.start_communication! }.to change(WorkOrderStatusChange, :count).by(1)
        
        status_change = work_order.work_order_status_changes.last
        expect(status_change.work_order_type).to eq("communication")
        expect(status_change.from_status).to eq("open")
        expect(status_change.to_status).to eq("in_progress")
        expect(status_change.changed_by).to eq(1)
      end
    end
  end
  
  describe "#add_communication_record" do
    let(:work_order) { create(:communication_work_order) }
    
    it "creates a communication record" do
      expect {
        work_order.add_communication_record(
          content: "测试沟通内容",
          communicator_role: "auditor",
          communicator_name: "测试人员",
          communication_method: "system"
        )
      }.to change(CommunicationRecord, :count).by(1)
      
      record = work_order.communication_records.last
      expect(record.content).to eq("测试沟通内容")
      expect(record.communicator_role).to eq("auditor")
      expect(record.communicator_name).to eq("测试人员")
      expect(record.communication_method).to eq("system")
    end
  end
  
  describe "#notify_parent_work_order" do
    let(:audit_work_order) { create(:audit_work_order, :needs_communication) }
    let(:work_order) { create(:communication_work_order, :in_progress, audit_work_order: audit_work_order) }
    
    it "updates parent work order status after resolve" do
      work_order.resolve!
      expect(audit_work_order.reload.status).to eq("auditing")
    end
    
    it "updates parent work order status after mark_unresolved" do
      work_order.mark_unresolved!
      expect(audit_work_order.reload.status).to eq("auditing")
    end
    
    it "does not update parent work order status if not in needs_communication state" do
      audit_work_order.update(status: "processing")
      work_order.resolve!
      expect(audit_work_order.reload.status).to eq("processing")
    end
  end
  
  describe "#select_fee_detail" do
    let(:work_order) { create(:communication_work_order) }
    let(:fee_detail) { create(:fee_detail, document_number: work_order.reimbursement.invoice_number) }
    
    it "creates a fee detail selection" do
      expect {
        work_order.select_fee_detail(fee_detail)
      }.to change(FeeDetailSelection, :count).by(1)
      
      selection = work_order.fee_detail_selections.find_by(fee_detail: fee_detail)
      expect(selection.verification_status).to eq("problematic")
    end
    
    it "does not create duplicate selections" do
      work_order.select_fee_detail(fee_detail)
      
      expect {
        work_order.select_fee_detail(fee_detail)
      }.not_to change(FeeDetailSelection, :count)
    end
  end
  
  describe "#resolve_fee_detail_issue" do
    let(:work_order) { create(:communication_work_order) }
    let(:fee_detail) { create(:fee_detail, document_number: work_order.reimbursement.invoice_number) }
    
    before do
      work_order.select_fee_detail(fee_detail)
    end
    
    it "updates the fee detail selection comment" do
      work_order.resolve_fee_detail_issue(fee_detail, "问题已解决")
      
      selection = work_order.fee_detail_selections.find_by(fee_detail: fee_detail)
      expect(selection.verification_comment).to eq("问题已解决")
    end
    
    it "returns false if the fee detail is not associated with the work order" do
      other_fee_detail = create(:fee_detail)
      expect(work_order.resolve_fee_detail_issue(other_fee_detail, "问题已解决")).to be_falsey
    end
  end
end
```

### 6. 创建沟通记录模型测试

创建 `spec/models/communication_record_spec.rb` 文件：

```ruby
# spec/models/communication_record_spec.rb
require 'rails_helper'

RSpec.describe CommunicationRecord, type: :model do
  describe "validations" do
    it { should validate_presence_of(:content) }
    it { should validate_presence_of(:communicator_role) }
  end
  
  describe "associations" do
    it { should belong_to(:communication_work_order) }
  end
  
  describe "callbacks" do
    it "sets recorded_at before create if not provided" do
      record = build(:communication_record, recorded_at: nil)
      record.save
      expect(record.recorded_at).to be_present
    end
    
    it "does not override recorded_at if provided" do
      time = 1.day.ago
      record = build(:communication_record, recorded_at: time)
      record.save
      expect(record.recorded_at).to be_within(1.second).of(time)
    end
  end
end
```
  end
end
```
### 7. 实现 ActiveAdmin 资源

创建 `app/admin/communication_work_orders.rb` 文件：

```ruby
# app/admin/communication_work_orders.rb
ActiveAdmin.register CommunicationWorkOrder do
  # 权限控制
  permit_params :reimbursement_id, :audit_work_order_id, :status, :communication_method, 
                :initiator_role, :resolution_summary, :created_by
  
  # 菜单设置
  menu priority: 4, label: "沟通工单"
  
  # 过滤器
  filter :reimbursement_id
  filter :audit_work_order_id
  filter :status, as: :select, collection: ["open", "in_progress", "resolved", "unresolved", "closed"]
  filter :communication_method
  filter :initiator_role
  filter :created_at
  
  # 自定义操作
  action_item :start_communication, only: :show, if: proc { resource.status == "open" } do
    link_to "开始沟通", start_communication_admin_communication_work_order_path(resource), method: :put
  end
  
  action_item :add_communication_record, only: :show, if: proc { resource.status == "in_progress" } do
    link_to "添加沟通记录", new_communication_record_admin_communication_work_order_path(resource)
  end
  
  action_item :resolve, only: :show, if: proc { resource.status == "in_progress" } do
    link_to "标记已解决", resolve_admin_communication_work_order_path(resource)
  end
  
  action_item :mark_unresolved, only: :show, if: proc { resource.status == "in_progress" } do
    link_to "标记未解决", mark_unresolved_admin_communication_work_order_path(resource)
  end
  
  action_item :close, only: :show, if: proc { ["resolved", "unresolved"].include?(resource.status) } do
    link_to "关闭", close_admin_communication_work_order_path(resource), method: :put
  end
  
  # 自定义页面
  member_action :start_communication, method: :put do
    service = CommunicationWorkOrderService.new(resource, current_admin_user)
    if service.start_communication
      redirect_to admin_communication_work_order_path(resource), notice: "工单已开始沟通"
    else
      redirect_to admin_communication_work_order_path(resource), alert: "操作失败"
    end
  end
  
  member_action :new_communication_record, method: :get do
    render "admin/communication_work_orders/new_communication_record"
  end
  
  member_action :create_communication_record, method: :post do
    service = CommunicationWorkOrderService.new(resource, current_admin_user)
    communication_record = service.add_communication_record(
      content: params[:content],
      communicator_role: params[:communicator_role],
      communicator_name: params[:communicator_name],
      communication_method: params[:communication_method]
    )
    
    if communication_record.persisted?
      redirect_to admin_communication_work_order_path(resource), notice: "沟通记录已添加"
    else
      redirect_to admin_communication_work_order_path(resource), alert: "添加沟通记录失败"
    end
  end
  
  member_action :resolve, method: :get do
    render "admin/communication_work_orders/resolve"
  end
  
  member_action :do_resolve, method: :post do
    service = CommunicationWorkOrderService.new(resource, current_admin_user)
    if service.resolve(params[:resolution_summary])
      redirect_to admin_communication_work_order_path(resource), notice: "工单已标记为已解决"
    else
      redirect_to admin_communication_work_order_path(resource), alert: "操作失败"
    end
  end
  
  member_action :mark_unresolved, method: :get do
    render "admin/communication_work_orders/mark_unresolved"
  end
  
  member_action :do_mark_unresolved, method: :post do
    service = CommunicationWorkOrderService.new(resource, current_admin_user)
    if service.mark_unresolved(params[:resolution_summary])
      redirect_to admin_communication_work_order_path(resource), notice: "工单已标记为未解决"
    else
      redirect_to admin_communication_work_order_path(resource), alert: "操作失败"
    end
  end
  
  member_action :close, method: :put do
    service = CommunicationWorkOrderService.new(resource, current_admin_user)
    if service.close
      redirect_to admin_communication_work_order_path(resource), notice: "工单已关闭"
    else
      redirect_to admin_communication_work_order_path(resource), alert: "操作失败"
    end
  end
  
  # 列表页
  index do
    selectable_column
    id_column
    column :reimbursement do |work_order|
      link_to work_order.reimbursement.invoice_number, admin_reimbursement_path(work_order.reimbursement)
    end
    column :audit_work_order do |work_order|
      link_to work_order.audit_work_order.id, admin_audit_work_order_path(work_order.audit_work_order)
    end
    column :status do |work_order|
      status_tag work_order.status
    end
    column :communication_method
    column :initiator_role
    column :created_at
    actions
  end
  
  # 详情页
  show do
    tabs do
      tab "基本信息" do
        attributes_table do
          row :id
          row :reimbursement do |work_order|
            link_to work_order.reimbursement.invoice_number, admin_reimbursement_path(work_order.reimbursement)
          end
          row :audit_work_order do |work_order|
            link_to work_order.audit_work_order.id, admin_audit_work_order_path(work_order.audit_work_order)
          end
          row :status do |work_order|
            status_tag work_order.status
          end
          row :communication_method
          row :initiator_role
          row :resolution_summary
          row :created_by
          row :created_at
          row :updated_at
        end
      end
      
      tab "沟通记录" do
        panel "沟通记录" do
          table_for resource.communication_records.order(recorded_at: :desc) do
            column :id
            column :communicator_role
            column :communicator_name
            column :communication_method
            column :content
            column :recorded_at
          end
        end
      end
      
      tab "费用明细" do
        panel "费用明细信息" do
          table_for resource.fee_details do
            column :id
            column :fee_type
            column :amount do |fee_detail|
              number_to_currency(fee_detail.amount, unit: "¥")
            end
            column :verification_status do |fee_detail|
              status_tag fee_detail.verification_status
            end
            column "验证状态" do |fee_detail|
              selection = resource.fee_detail_selections.find_by(fee_detail: fee_detail)
              status_tag selection.verification_status if selection.present?
            end
            column "操作" do |fee_detail|
              links = []
              links << link_to("查看", admin_fee_detail_path(fee_detail))
              links << link_to("解决问题", resolve_issue_admin_fee_detail_path(fee_detail, work_order_id: resource.id))
              links.join(" | ").html_safe
            end
          end
        end
      end
      
      tab "状态变更历史" do
        panel "状态变更历史" do
          table_for resource.work_order_status_changes.order(changed_at: :desc) do
            column :from_status
            column :to_status
            column :changed_at
            column :changed_by
          end
        end
      end
    end
  end
  
  # 表单
  form do |f|
    f.inputs "沟通工单信息" do
      f.input :reimbursement_id, as: :select, collection: Reimbursement.all.map { |r| [r.invoice_number, r.id] }
      f.input :audit_work_order_id, as: :select, collection: AuditWorkOrder.all.map { |w| [w.id, w.id] }
      f.input :status, as: :select, collection: ["open", "in_progress", "resolved", "unresolved", "closed"]
      f.input :communication_method, as: :select, collection: ["email", "phone", "system", "other"]
      f.input :initiator_role, as: :select, collection: ["auditor", "applicant", "manager", "other"]
      f.input :resolution_summary
      f.input :created_by, input_html: { value: current_admin_user.id }, as: :hidden
    end
    f.actions
  end
end
```

### 8. 创建沟通工单视图模板

创建 `app/views/admin/communication_work_orders/new_communication_record.html.erb` 文件：

```erb
<!-- app/views/admin/communication_work_orders/new_communication_record.html.erb -->
<h2>添加沟通记录</h2>

<%= form_tag create_communication_record_admin_communication_work_order_path(@communication_work_order), method: :post do %>
  <div class="panel">
    <div class="panel_contents">
      <div class="attributes_table">
        <table>
          <tr>
            <th>沟通内容</th>
            <td><%= text_area_tag :content, nil, rows: 5, cols: 50, required: true %></td>
          </tr>
          <tr>
            <th>沟通角色</th>
            <td>
              <%= select_tag :communicator_role, options_for_select([
                ["审核人", "auditor"],
                ["申请人", "applicant"],
                ["管理员", "admin"],
                ["其他", "other"]
              ]), required: true %>
            </td>
          </tr>
          <tr>
            <th>沟通人姓名</th>
            <td><%= text_field_tag :communicator_name, current_admin_user.email %></td>
          </tr>
          <tr>
            <th>沟通方式</th>
            <td>
              <%= select_tag :communication_method, options_for_select([
                ["系统", "system"],
                ["邮件", "email"],
                ["电话", "phone"],
                ["其他", "other"]
              ]), required: true %>
            </td>
          </tr>
        </table>
      </div>
    </div>
  </div>
  
  <div class="actions">
    <%= submit_tag "添加记录", class: "button" %>
    <%= link_to "取消", admin_communication_work_order_path(@communication_work_order), class: "button" %>
  </div>
<% end %>
```

创建 `app/views/admin/communication_work_orders/resolve.html.erb` 文件：

```erb
<!-- app/views/admin/communication_work_orders/resolve.html.erb -->
<h2>标记沟通工单为已解决</h2>

<%= form_tag do_resolve_admin_communication_work_order_path(@communication_work_order), method: :post do %>
  <div class="panel">
    <div class="panel_contents">
      <div class="attributes_table">
        <table>
          <tr>
            <th>报销单号</th>
            <td><%= @communication_work_order.reimbursement.invoice_number %></td>
          </tr>
          <tr>
            <th>申请人</th>
            <td><%= @communication_work_order.reimbursement.applicant %></td>
          </tr>
          <tr>
            <th>解决方案</th>
            <td><%= text_area_tag :resolution_summary, nil, rows: 5, cols: 50, required: true %></td>
          </tr>
        </table>
      </div>
    </div>
  </div>
  
  <div class="actions">
    <%= submit_tag "确认已解决", class: "button" %>
    <%= link_to "取消", admin_communication_work_order_path(@communication_work_order), class: "button" %>
  </div>
<% end %>
```

创建 `app/views/admin/communication_work_orders/mark_unresolved.html.erb` 文件：

```erb
<!-- app/views/admin/communication_work_orders/mark_unresolved.html.erb -->
<h2>标记沟通工单为未解决</h2>

<%= form_tag do_mark_unresolved_admin_communication_work_order_path(@communication_work_order), method: :post do %>
  <div class="panel">
    <div class="panel_contents">
      <div class="attributes_table">
        <table>
          <tr>
            <th>报销单号</th>
            <td><%= @communication_work_order.reimbursement.invoice_number %></td>
          </tr>
          <tr>
            <th>申请人</th>
            <td><%= @communication_work_order.reimbursement.applicant %></td>
          </tr>
          <tr>
            <th>未解决原因</th>
            <td><%= text_area_tag :resolution_summary, nil, rows: 5, cols: 50, required: true %></td>
          </tr>
        </table>
      </div>
    </div>
  </div>
  
  <div class="actions">
    <%= submit_tag "确认未解决", class: "button" %>
    <%= link_to "取消", admin_communication_work_order_path(@communication_work_order), class: "button" %>
  </div>
<% end %>
```

## 测试验证方法

1. 运行 `rspec spec/models/communication_work_order_spec.rb spec/models/communication_record_spec.rb` 确保所有测试通过
2. 在 Rails 控制台中测试模型功能：
   ```ruby
   # 创建报销单
   reimbursement = Reimbursement.create!(
     invoice_number: "R20250101001",
     document_name: "测试报销单",
     applicant: "张三",
     applicant_id: "EMP001",
     company: "测试公司",
     department: "测试部门",
     amount: 1000.00,
     is_electronic: false
   )
   
   # 创建审核工单
   audit_work_order = AuditWorkOrder.create!(
     reimbursement: reimbursement,
     status: "needs_communication",
     created_by: 1
   )
   
   # 创建沟通工单
   work_order = CommunicationWorkOrder.create!(
     reimbursement: reimbursement,
     audit_work_order: audit_work_order,
     status: "open",
     communication_method: "email",
     initiator_role: "auditor",
     created_by: 1
   )
   
   # 测试状态转换
   work_order.start_communication!
   work_order.status # 应该返回 "in_progress"
   
   # 测试添加沟通记录
   record = work_order.add_communication_record(
     content: "测试沟通内容",
     communicator_role: "auditor",
     communicator_name: "测试人员",
     communication_method: "email"
   )
   
   record.persisted? # 应该返回 true
   work_order.communication_records.count # 应该返回 1
   
   # 测试解决沟通工单
   work_order.resolve!
   work_order.status # 应该返回 "resolved"
   audit_work_order.reload.status # 应该返回 "auditing"
   
   # 测试关闭沟通工单
   work_order.close!
   work_order.status # 应该返回 "closed"
   ```
3. 启动 Rails 服务器，访问 ActiveAdmin 界面，测试沟通工单管理功能

## 注意事项

1. 确保 AASM 状态机正确配置，特别是状态转换和回调
2. 确保状态变更记录功能正确实现
3. 确保沟通记录功能正确实现
4. 确保费用明细关联功能正确实现
5. 确保与报销单和审核工单的关联关系正确设置
6. 确保 ActiveAdmin 配置正确，特别是自定义操作和表单