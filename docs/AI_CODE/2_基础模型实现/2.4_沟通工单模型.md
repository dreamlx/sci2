# 沟通工单模型实现

## 任务描述

实现沟通工单（CommunicationWorkOrder）模型，作为工单系统的核心工单类型之一。沟通工单负责处理审核过程中的沟通，记录沟通过程，并在解决后通知父审核工单恢复审核流程。

## 输入和依赖

- 数据库迁移脚本（已创建的沟通工单表）
- 报销单模型（Reimbursement）
- 审核工单模型（AuditWorkOrder）
- 模型实现设计文档 (`docs/refactoring/03_model_implementation.md`)

## 期望输出

完整的沟通工单模型实现，包括：
- 模型属性和验证
- 与报销单和审核工单的关联关系
- 状态机实现
- 状态变更记录功能
- 沟通记录功能
- 通知父工单的功能
- ActiveAdmin 配置

## 详细实现步骤

### 1. 创建沟通工单模型

创建 `app/models/communication_work_order.rb` 文件：

```ruby
class CommunicationWorkOrder < ApplicationRecord
  # 关联
  belongs_to :reimbursement
  belongs_to :audit_work_order
  has_many :communication_records, dependent: :destroy
  has_many :fee_detail_selections, dependent: :destroy
  has_many :fee_details, through: :fee_detail_selections
  has_many :work_order_status_changes, as: :work_order, dependent: :destroy

  # 验证
  validates :status, presence: true
  validates :reimbursement_id, presence: true
  validates :audit_work_order_id, presence: true

  # 回调
  after_save :record_status_change, if: :saved_change_to_status?

  # 状态机
  state_machine :status, initial: :open do
    # 定义状态
    state :open, :in_progress, :resolved, :unresolved, :closed

    # 定义事件
    event :start_communication do
      transition open: :in_progress
    end

    event :resolve do
      transition in_progress: :resolved
      after do
        notify_parent_work_order
      end
    end

    event :mark_unresolved do
      transition in_progress: :unresolved
      after do
        notify_parent_work_order
      end
    end

    event :close do
      transition [:resolved, :unresolved] => :closed
    end

    # 状态转换前的回调
    before_transition any => any do |work_order, transition|
      # 可以在这里添加额外的验证逻辑
    end
  end
# 方法
  def add_communication_record(params)
    communication_records.create(params)
  end

  def notify_parent_work_order
    return unless audit_work_order.present?

    if audit_work_order.status == 'needs_communication'
      audit_work_order.resume_audit
    end
  end

  def select_fee_detail(fee_detail)
    fee_detail_selections.find_or_create_by(fee_detail: fee_detail) do |selection|
      selection.verification_status = 'problematic'
    end
  end

  def resolve_fee_detail_issue(fee_detail, resolution)
    selection = fee_detail_selections.find_by(fee_detail: fee_detail)
    return false unless selection

    # 更新选择记录
    selection.update(
      verification_comment: resolution
    )

    true
  end

  # 获取状态变更历史
  def status_changes
    work_order_status_changes.order(changed_at: :desc)
  end

  private

  # 记录状态变更
  def record_status_change
    if saved_change_to_status?
      old_status, new_status = saved_change_to_status
      work_order_status_changes.create(
        work_order_type: 'communication',
        from_status: old_status,
        to_status: new_status,
        changed_at: Time.current,
        changed_by: Current.admin_user&.id
      )
    end
  end

  # ActiveAdmin配置
  def self.ransackable_attributes(auth_object = nil)
    %w[id reimbursement_id audit_work_order_id status communication_method initiator_role resolution_summary created_by created_at updated_at]
  end

  def self.ransackable_associations(auth_object = nil)
    %w[reimbursement audit_work_order communication_records fee_detail_selections fee_details work_order_status_changes]
  end
end
```

### 2. 创建沟通记录模型

创建 `app/models/communication_record.rb` 文件：

```ruby
class CommunicationRecord < ApplicationRecord
  # 关联
  belongs_to :communication_work_order

  # 验证
  validates :content, presence: true
  validates :communicator_role, presence: true
  validates :communication_work_order_id, presence: true

  # 回调
  before_create :set_recorded_at

  private

  def set_recorded_at
    self.recorded_at ||= Time.current
  end

  # ActiveAdmin配置
  def self.ransackable_attributes(auth_object = nil)
    %w[id communication_work_order_id content communicator_role communicator_name communication_method recorded_at created_at updated_at]
  end

  def self.ransackable_associations(auth_object = nil)
    %w[communication_work_order]
  end
end
```

### 3. 创建沟通工单工厂

创建 `spec/factories/communication_work_orders.rb` 文件：

```ruby
FactoryBot.define do
  factory :communication_work_order do
    association :reimbursement
    association :audit_work_order, factory: :audit_work_order, strategy: :build
    status { 'open' }
    communication_method { 'email' }
    initiator_role { 'auditor' }
    created_by { 1 }

    trait :in_progress do
      status { 'in_progress' }
    end

    trait :resolved do
      status { 'resolved' }
      resolution_summary { '问题已解决' }
    end

    trait :unresolved do
      status { 'unresolved' }
      resolution_summary { '无法解决' }
    end

    trait :closed do
      status { 'closed' }
    end

    trait :with_records do
      transient do
        records_count { 2 }
      end

      after(:create) do |work_order, evaluator|
        create_list(:communication_record, evaluator.records_count, communication_work_order: work_order)
      end
    end

    trait :with_fee_details do
      transient do
        fee_details_count { 2 }
      end

      after(:create) do |work_order, evaluator|
        create_list(:fee_detail, evaluator.fee_details_count, document_number: work_order.reimbursement.invoice_number).each do |fee_detail|
          work_order.select_fee_detail(fee_detail)
        end
      end
    end
  end
end
```

### 4. 创建沟通记录工厂

创建 `spec/factories/communication_records.rb` 文件：

```ruby
FactoryBot.define do
  factory :communication_record do
    association :communication_work_order
    content { "沟通内容示例" }
    communicator_role { "auditor" }
    communicator_name { "审核人员" }
    communication_method { "email" }
    recorded_at { Time.current }
  end
### 5. 创建沟通工单模型测试

创建 `spec/models/communication_work_order_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe CommunicationWorkOrder, type: :model do
  describe "validations" do
    it { should validate_presence_of(:status) }
    it { should validate_presence_of(:reimbursement_id) }
    it { should validate_presence_of(:audit_work_order_id) }
  end

  describe "associations" do
    it { should belong_to(:reimbursement) }
    it { should belong_to(:audit_work_order) }
    it { should have_many(:communication_records).dependent(:destroy) }
    it { should have_many(:fee_detail_selections).dependent(:destroy) }
    it { should have_many(:fee_details).through(:fee_detail_selections) }
    it { should have_many(:work_order_status_changes).dependent(:destroy) }
  end

  describe "state machine" do
    let(:work_order) { create(:communication_work_order) }

    it "has initial state of open" do
      expect(work_order.status).to eq('open')
    end

    context "when starting communication" do
      it "can transition from open to in_progress" do
        expect(work_order).to be_open
        expect(work_order.start_communication).to be_truthy
        expect(work_order).to be_in_progress
      end
    end

    context "when resolving" do
      before do
        work_order.update(status: 'in_progress')
      end

      it "can transition from in_progress to resolved" do
        expect(work_order).to be_in_progress
        expect(work_order.resolve).to be_truthy
        expect(work_order).to be_resolved
      end

      it "notifies parent work order after resolution" do
        # Set parent work order to needs_communication
        work_order.audit_work_order.update(status: 'needs_communication')
        
        # Resolve communication work order
        work_order.resolve
        
        # Check if parent work order status changed
        expect(work_order.audit_work_order.reload.status).to eq('auditing')
      end
    end

    context "when marking unresolved" do
      before do
        work_order.update(status: 'in_progress')
      end

      it "can transition from in_progress to unresolved" do
        expect(work_order).to be_in_progress
        expect(work_order.mark_unresolved).to be_truthy
        expect(work_order).to be_unresolved
      end

      it "notifies parent work order after marking unresolved" do
        # Set parent work order to needs_communication
        work_order.audit_work_order.update(status: 'needs_communication')
        
        # Mark communication work order as unresolved
        work_order.mark_unresolved
        
        # Check if parent work order status changed
        expect(work_order.audit_work_order.reload.status).to eq('auditing')
      end
    end

    context "when closing" do
      context "from resolved" do
        before do
          work_order.update(status: 'resolved')
        end

        it "can transition from resolved to closed" do
          expect(work_order).to be_resolved
          expect(work_order.close).to be_truthy
          expect(work_order).to be_closed
        end
      end

      context "from unresolved" do
        before do
          work_order.update(status: 'unresolved')
        end

        it "can transition from unresolved to closed" do
          expect(work_order).to be_unresolved
          expect(work_order.close).to be_truthy
          expect(work_order).to be_closed
        end
      end
    end
  end

  describe "#add_communication_record" do
    let(:work_order) { create(:communication_work_order) }

    it "creates a communication record" do
      expect {
        work_order.add_communication_record(
          content: "测试沟通内容",
          communicator_role: "auditor",
          communicator_name: "测试人员",
          communication_method: "email"
        )
      }.to change(CommunicationRecord, :count).by(1)
    end

    it "associates the record with the work order" do
      record = work_order.add_communication_record(
        content: "测试沟通内容",
        communicator_role: "auditor"
      )
      expect(record.communication_work_order).to eq(work_order)
    end
  end

  describe "#select_fee_detail" do
    let(:work_order) { create(:communication_work_order) }
    let(:fee_detail) { create(:fee_detail, document_number: work_order.reimbursement.invoice_number) }

    it "creates a fee detail selection" do
      expect {
        work_order.select_fee_detail(fee_detail)
      }.to change(FeeDetailSelection, :count).by(1)
    end

    it "sets verification status to problematic" do
      selection = work_order.select_fee_detail(fee_detail)
      expect(selection.verification_status).to eq('problematic')
    end

    it "does not create duplicate selections" do
      work_order.select_fee_detail(fee_detail)
      expect {
        work_order.select_fee_detail(fee_detail)
      }.not_to change(FeeDetailSelection, :count)
    end
  end

  describe "#resolve_fee_detail_issue" do
    let(:work_order) { create(:communication_work_order, :with_fee_details) }
    let(:fee_detail) { work_order.fee_details.first }

    it "updates fee detail selection verification comment" do
      work_order.resolve_fee_detail_issue(fee_detail, "问题已解决")
      selection = work_order.fee_detail_selections.find_by(fee_detail: fee_detail)
      expect(selection.verification_comment).to eq("问题已解决")
    end

    it "returns false if fee detail is not associated with the work order" do
      unrelated_fee_detail = create(:fee_detail)
      expect(work_order.resolve_fee_detail_issue(unrelated_fee_detail, "问题已解决")).to be_falsey
    end
  end

  describe "status change recording" do
    let(:work_order) { create(:communication_work_order) }

    it "records status change when status changes" do
      expect {
        work_order.start_communication
      }.to change(WorkOrderStatusChange, :count).by(1)

      status_change = WorkOrderStatusChange.last
      expect(status_change.work_order_type).to eq('communication')
      expect(status_change.work_order_id).to eq(work_order.id)
      expect(status_change.from_status).to eq('open')
      expect(status_change.to_status).to eq('in_progress')
    end
  end
end
```

### 6. 创建沟通记录模型测试

创建 `spec/models/communication_record_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe CommunicationRecord, type: :model do
  describe "validations" do
    it { should validate_presence_of(:content) }
    it { should validate_presence_of(:communicator_role) }
    it { should validate_presence_of(:communication_work_order_id) }
  end

  describe "associations" do
    it { should belong_to(:communication_work_order) }
  end

  describe "callbacks" do
    it "sets recorded_at before create if not provided" do
      record = build(:communication_record, recorded_at: nil)
      record.save
      expect(record.recorded_at).not_to be_nil
    end
### 7. 创建 ActiveAdmin 资源

创建 `app/admin/communication_work_orders.rb` 文件（如果尚未创建）：

```ruby
ActiveAdmin.register CommunicationWorkOrder do
  # 权限控制
  permit_params :reimbursement_id, :audit_work_order_id, :status, :communication_method,
                :initiator_role, :resolution_summary, :created_by

  # 菜单设置
  menu priority: 4, label: "沟通工单"

  # 过滤器
  filter :reimbursement_invoice_number, as: :string, label: '报销单号'
  filter :audit_work_order_id
  filter :status, as: :select, collection: CommunicationWorkOrder.state_machines[:status].states.map(&:name)
  filter :communication_method
  filter :initiator_role
  filter :created_at

  # 自定义操作
  action_item :start_communication, only: :show, if: proc { resource.status == 'open' } do
    link_to "开始沟通", start_communication_admin_communication_work_order_path(resource), method: :put
  end

  action_item :add_communication_record, only: :show, if: proc { resource.status == 'in_progress' } do
    link_to "添加沟通记录", new_communication_record_admin_communication_work_order_path(resource)
  end

  action_item :resolve, only: :show, if: proc { resource.status == 'in_progress' } do
    link_to "标记已解决", resolve_admin_communication_work_order_path(resource)
  end

  action_item :mark_unresolved, only: :show, if: proc { resource.status == 'in_progress' } do
    link_to "标记未解决", mark_unresolved_admin_communication_work_order_path(resource)
  end

  action_item :close, only: :show, if: proc { ['resolved', 'unresolved'].include?(resource.status) } do
    link_to "关闭", close_admin_communication_work_order_path(resource), method: :put
  end

  # 自定义页面
  member_action :start_communication, method: :put do
    begin
      resource.start_communication
      redirect_to admin_communication_work_order_path(resource), notice: "工单已开始沟通"
    rescue StateMachines::InvalidTransition => e
      redirect_to admin_communication_work_order_path(resource), alert: "状态转换失败: #{e.message}"
    end
  end

  member_action :new_communication_record, method: :get do
    render :new_communication_record
  end

  member_action :create_communication_record, method: :post do
    record = resource.add_communication_record(params.require(:communication_record).permit(:content, :communicator_role, :communicator_name, :communication_method))
    if record.persisted?
      redirect_to admin_communication_work_order_path(resource), notice: "沟通记录已添加"
    else
      render :new_communication_record, alert: "添加沟通记录失败: #{record.errors.full_messages.join(', ')}"
    end
  end

  member_action :resolve, method: :get do
    render :resolve
  end

  member_action :do_resolve, method: :post do
    begin
      resource.update(resolution_summary: params[:resolution_summary])
      resource.resolve
      redirect_to admin_communication_work_order_path(resource), notice: "工单已标记为已解决"
    rescue StateMachines::InvalidTransition => e
      redirect_to admin_communication_work_order_path(resource), alert: "状态转换失败: #{e.message}"
    end
  end

  member_action :mark_unresolved, method: :get do
    render :mark_unresolved
  end

  member_action :do_mark_unresolved, method: :post do
    begin
      resource.update(resolution_summary: params[:resolution_summary])
      resource.mark_unresolved
      redirect_to admin_communication_work_order_path(resource), notice: "工单已标记为未解决"
    rescue StateMachines::InvalidTransition => e
      redirect_to admin_communication_work_order_path(resource), alert: "状态转换失败: #{e.message}"
    end
  end

  member_action :close, method: :put do
    begin
      resource.close
      redirect_to admin_communication_work_order_path(resource), notice: "工单已关闭"
    rescue StateMachines::InvalidTransition => e
      redirect_to admin_communication_work_order_path(resource), alert: "状态转换失败: #{e.message}"
    end
  end

  member_action :resolve_fee_detail_issue, method: :get do
    @fee_detail = FeeDetail.find(params[:fee_detail_id])
    render :resolve_fee_detail_issue
  end

  member_action :do_resolve_fee_detail_issue, method: :post do
    fee_detail = FeeDetail.find(params[:fee_detail_id])
    if resource.resolve_fee_detail_issue(fee_detail, params[:resolution])
      redirect_to admin_communication_work_order_path(resource), notice: "费用明细 ##{params[:fee_detail_id]} 问题备注已更新"
    else
      @fee_detail = fee_detail
      render :resolve_fee_detail_issue, alert: "更新费用明细备注失败"
    end
  end

  # 列表页
  index do
    selectable_column
    id_column
    column :reimbursement do |work_order|
      link_to work_order.reimbursement.invoice_number, admin_reimbursement_path(work_order.reimbursement)
    end
    column :audit_work_order do |work_order|
      link_to work_order.audit_work_order.id, admin_audit_work_order_path(work_order.audit_work_order)
    end
    column :status do |work_order|
      status_tag work_order.status
    end
    column :communication_method
    column :initiator_role
    column :created_at
    actions
  end

  # 详情页
  show do
    tabs do
      tab "基本信息" do
        attributes_table do
          row :id
          row :reimbursement do |work_order|
            link_to work_order.reimbursement.invoice_number, admin_reimbursement_path(work_order.reimbursement)
          end
          row :audit_work_order do |work_order|
            link_to work_order.audit_work_order.id, admin_audit_work_order_path(work_order.audit_work_order)
          end
          row :status do |work_order|
            status_tag work_order.status
          end
          row :communication_method
          row :initiator_role
          row :resolution_summary
          row :created_by
          row :created_at
          row :updated_at
        end
      end

      tab "沟通记录" do
        panel "沟通记录" do
          table_for resource.communication_records.order(recorded_at: :desc) do
            column :id
            column :communicator_role
            column :communicator_name
            column :communication_method
            column :content
            column :recorded_at
          end
        end
      end

      tab "关联费用明细" do
        panel "费用明细信息" do
          table_for resource.fee_detail_selections.includes(:fee_detail) do
            column "费用明细ID", :fee_detail_id do |sel|
              link_to sel.fee_detail_id, admin_fee_detail_path(sel.fee_detail)
            end
            column "费用类型", :fee_type do |sel|
              sel.fee_detail.fee_type
            end
            column "金额", :amount do |sel|
              number_to_currency(sel.fee_detail.amount, unit: "¥")
            end
            column "验证状态 (工单内)", :verification_status do |sel|
              status_tag sel.verification_status
            end
            column "验证状态 (全局)", :global_status do |sel|
              status_tag sel.fee_detail.verification_status
            end
            column "验证意见", :verification_comment
            column "操作" do |sel|
              links = []
              links << link_to("添加/更新解决备注", resolve_fee_detail_issue_admin_communication_work_order_path(resource, fee_detail_id: sel.fee_detail_id))
              links.join(" | ").html_safe
            end
          end
        end
      end

      tab "状态变更历史" do
        panel "状态变更历史" do
          table_for resource.status_changes do
            column :from_status
            column :to_status
            column :changed_at
            column :changed_by do |change|
              AdminUser.find_by(id: change.changed_by)&.email
            end
          end
        end
      end
    end
  end

  # 表单
  form do |f|
    f.inputs "沟通工单信息" do
      f.input :reimbursement_id, as: :select, collection: Reimbursement.all.map { |r| [r.invoice_number, r.id] }
      f.input :audit_work_order_id, as: :select, collection: AuditWorkOrder.all.map { |w| [w.id, w.id] }
      f.input :status, as: :select, collection: CommunicationWorkOrder.state_machines[:status].states.map(&:name)
      f.input :communication_method, as: :select, collection: ["email", "phone", "system", "other"]
      f.input :initiator_role, as: :select, collection: ["auditor", "applicant", "manager", "other"]
      f.input :resolution_summary
      f.input :created_by, input_html: { value: current_admin_user.id }, as: :hidden
    end
    f.actions
  end
end
```

### 8. 创建 ActiveAdmin 资源（沟通记录）

创建 `app/admin/communication_records.rb` 文件（如果尚未创建）：

```ruby
ActiveAdmin.register CommunicationRecord do
  # 权限控制
  permit_params :communication_work_order_id, :content, :communicator_role,
                :communicator_name, :communication_method, :recorded_at

  # 菜单设置
  menu priority: 5, label: "沟通记录", parent: "沟通工单"

  # 过滤器
  filter :communication_work_order_id
  filter :communicator_role
  filter :communication_method
  filter :recorded_at
  filter :created_at

  # 列表页
  index do
    selectable_column
    id_column
    column :communication_work_order
    column :communicator_role
    column :communicator_name
    column :communication_method
    column :content
    column :recorded_at
    actions
  end

  # 详情页
  show do
    attributes_table do
      row :id
      row :communication_work_order
      row :content
      row :communicator_role
      row :communicator_name
      row :communication_method
      row :recorded_at
      row :created_at
      row :updated_at
    end
  end

  # 表单
  form do |f|
    f.inputs "沟通记录信息" do
      f.input :communication_work_order
      f.input :content
      f.input :communicator_role, as: :select, collection: ["auditor", "applicant", "manager", "other"]
      f.input :communicator_name
      f.input :communication_method, as: :select, collection: ["email", "phone", "system", "other"]
      f.input :recorded_at, as: :datepicker
    end
    f.actions
  end
end
```

## 测试验证方法

1. 运行 `rspec spec/models/communication_work_order_spec.rb spec/models/communication_record_spec.rb` 确保所有测试通过
2. 在 Rails 控制台中测试模型功能：

```ruby
# 创建报销单
reimbursement = Reimbursement.create!(
  invoice_number: "R20250101001",
  document_name: "测试报销单",
  applicant: "张三",
  applicant_id: "EMP001",
  company: "测试公司",
  department: "测试部门",
  amount: 1000.00
)

# 创建审核工单
audit_work_order = AuditWorkOrder.create!(
  reimbursement: reimbursement,
  status: 'auditing',
  created_by: 1
)

# 创建费用明细
fee_detail = FeeDetail.create!(
  document_number: reimbursement.invoice_number,
  fee_type: "交通费",
  amount: 150.0,
  verification_status: "pending"
)

# 创建沟通工单
work_order = CommunicationWorkOrder.create!(
  reimbursement: reimbursement,
  audit_work_order: audit_work_order,
  status: 'open',
  communication_method: 'email',
  initiator_role: 'auditor',
  created_by: 1
)

# 关联费用明细
work_order.select_fee_detail(fee_detail)

# 测试状态转换
puts "初始状态: #{work_order.status}"
work_order.start_communication
puts "开始沟通后状态: #{work_order.status}"

# 测试添加沟通记录
record = work_order.add_communication_record(
  content: "测试沟通内容",
  communicator_role: "auditor",
  communicator_name: "测试人员",
  communication_method: "email"
)
puts "沟通记录ID: #{record.id}, 内容: #{record.content}"

# 测试解决费用明细问题
work_order.resolve_fee_detail_issue(fee_detail, "问题已解决")
selection = work_order.fee_detail_selections.find_by(fee_detail: fee_detail)
puts "费用明细问题备注: #{selection.verification_comment}"

# 测试标记为已解决
audit_work_order.update(status: 'needs_communication')
work_order.resolve
puts "解决后状态: #{work_order.status}"
puts "审核工单状态: #{audit_work_order.reload.status}"

# 测试关闭
work_order.close
puts "关闭后状态: #{work_order.status}"
```

3. 启动 Rails 服务器，访问 ActiveAdmin 界面，测试沟通工单管理功能

## 注意事项

1. 确保状态机正确实现，特别是状态转换和回调函数
2. 确保状态变更记录功能正确实现
3. 确保沟通记录功能正确实现
4. 确保通知父工单的功能正确实现，特别是在解决或标记为未解决后
5. 确保与报销单和审核工单的关联关系正确设置
6. 确保 ActiveAdmin 配置正确，特别是状态转换操作和沟通记录添加界面
7. 注意使用 `state_machines` gem 而不是 AASM，确保语法正确
8. 确保测试覆盖所有关键功能，特别是状态转换、回调函数和业务方法

    it "does not change recorded_at if already set" do
      time = 1.day.ago
      record = build(:communication_record, recorded_at: time)
      record.save
      expect(record.recorded_at).to be_within(1.second).of(time)
    end
  end
end
```
end
```