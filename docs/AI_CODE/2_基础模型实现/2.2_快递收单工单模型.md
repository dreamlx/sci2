# 任务：实现快递收单工单模型 (ExpressReceiptWorkOrder)

## 任务描述

实现工单基类（WorkOrder）和快递收单工单子类（ExpressReceiptWorkOrder）。工单基类是所有工单类型的父类，采用单表继承（STI）模式实现。快递收单工单是一种特殊的工单类型，在导入时自动创建，状态固定为 `completed`，并且会触发关联报销单的状态更新。

## 输入和依赖

- 数据库迁移脚本（已创建的 work_orders 表）
- 模型实现设计文档 (`docs/refactoring/03_model_implementation.md`)
- STI 模型设计 (`docs/00LLM_AI开发任务分解指南.md` 中的 1.2 工单类型与状态流)
- 报销单模型 (`app/models/reimbursement.rb`)

## 期望输出

完整的工单基类和快递收单工单子类实现，包括：
- WorkOrder 基类定义
- ExpressReceiptWorkOrder 子类定义
- 继承关系和多态关联
- 验证规则
- 回调方法
- 业务方法
- ActiveAdmin 配置

## 详细实现步骤

### 1. 创建 Current 类用于存储当前用户

创建 `app/models/current.rb` 文件：

```ruby
# app/models/current.rb
class Current < ActiveSupport::CurrentAttributes
  attribute :admin_user
end
```

### 2. 创建 WorkOrder 基类

创建 `app/models/work_order.rb` 文件：

```ruby
# app/models/work_order.rb
class WorkOrder < ApplicationRecord
  self.inheritance_column = :type # 显式定义 STI 列
  
  # 关联
  belongs_to :reimbursement
  belongs_to :creator, class_name: 'AdminUser', foreign_key: 'created_by', optional: true
  
  # 多态关联
  has_many :fee_detail_selections, as: :work_order, dependent: :destroy
  has_many :fee_details, through: :fee_detail_selections
  has_many :work_order_status_changes, as: :work_order, dependent: :destroy
  
  # 验证
  validates :reimbursement_id, presence: true
  validates :type, presence: true
  validates :status, presence: true
  
  # 回调
  # 使用 after_commit 确保状态变更在成功保存后记录
  after_commit :record_status_change, on: [:create, :update], if: :saved_change_to_status?
  after_create :update_reimbursement_status_on_create
  
  # 方法
  def self.sti_name
    name
  end
  
  # ActiveAdmin 配置
  def self.ransackable_attributes(auth_object = nil)
    # 公共字段 + 子类特定字段
    %w[id reimbursement_id type status created_by created_at updated_at] + 
    subclass_ransackable_attributes
  end
  
  def self.ransackable_associations(auth_object = nil)
    %w[reimbursement creator fee_detail_selections fee_details work_order_status_changes] + 
    subclass_ransackable_associations
  end
  
  # 子类的占位方法
  def self.subclass_ransackable_attributes
    []
  end
  
  def self.subclass_ransackable_associations
    []
  end
  
  private
  
  def record_status_change
    # 从事务变更中获取状态变更详情
    status_change = previous_changes['status']
    return unless status_change # 确保状态确实发生了变化
    
    old_status, new_status = status_change
    work_order_status_changes.create!(
      work_order_type: self.class.sti_name,
      from_status: old_status,
      to_status: new_status,
      changed_at: Time.current,
      # 确保 Current.admin_user 在服务/控制器中设置
      changed_by: Current.admin_user&.id || creator&.id
    )
  end
  
  def update_reimbursement_status_on_create
    # 当创建审核或沟通工单时触发报销单状态更新
    if self.is_a?(AuditWorkOrder) || self.is_a?(CommunicationWorkOrder)
      reimbursement.start_processing! if reimbursement.pending?
    end
  rescue StateMachines::InvalidTransition => e
    Rails.logger.error "Error updating reimbursement status from WorkOrder ##{id} creation: #{e.message}"
  end
  
  # 状态机回调的辅助方法
  def update_associated_fee_details_status(new_status)
    valid_statuses = ['problematic', 'verified']
    return unless valid_statuses.include?(new_status)
    
    # 使用 FeeDetailVerificationService
    # 确保在调用状态机事件前适当设置 Current.admin_user
    verification_service = FeeDetailVerificationService.new(Current.admin_user || creator)
    # 如果性能成为问题，使用预加载
    fee_details.find_each do |fee_detail|
      # 仅当尚未验证时更新（允许 problematic -> verified）
      if fee_detail.verification_status == 'pending' || fee_detail.verification_status == 'problematic'
        verification_service.update_verification_status(fee_detail, new_status)
      end
    end
  end
end
```

### 3. 创建快递收单工单模型

创建 `app/models/express_receipt_work_order.rb` 文件：

```ruby
# app/models/express_receipt_work_order.rb
class ExpressReceiptWorkOrder < WorkOrder
  # 验证
  validates :tracking_number, presence: true
  validates :status, inclusion: { in: ['completed'] } # 唯一允许的状态
  
  # 重写 ransackable 方法
  def self.subclass_ransackable_attributes
    # 继承的公共字段 + 特定字段
    %w[tracking_number received_at courier_name]
  end
  
  def self.subclass_ransackable_associations
    [] # 无特定关联
  end
  
  # 无需状态机，状态固定为 completed
  
  # 业务方法
  def mark_reimbursement_as_received
    reimbursement.mark_as_received(received_at || Time.current)
  end
end
```

### 4. 创建工厂 (Factory) 用于测试

创建 `spec/factories/work_orders.rb` 文件：

```ruby
# spec/factories/work_orders.rb
FactoryBot.define do
  factory :work_order do
    association :reimbursement
    association :creator, factory: :admin_user
    
    # 子类工厂
    factory :express_receipt_work_order, class: 'ExpressReceiptWorkOrder' do
      type { "ExpressReceiptWorkOrder" }
      status { "completed" }
      sequence(:tracking_number) { |n| "SF#{1000 + n}" }
      received_at { Time.current - 1.day }
      courier_name { "顺丰" }
    end
  end
end
```

### 5. 编写单元测试

创建 `spec/models/work_order_spec.rb` 文件：

```ruby
# spec/models/work_order_spec.rb
require 'rails_helper'

RSpec.describe WorkOrder, type: :model do
  # 关联测试
  describe "associations" do
    it { should belong_to(:reimbursement) }
    it { should belong_to(:creator).optional }
    it { should have_many(:fee_detail_selections).dependent(:destroy) }
    it { should have_many(:fee_details).through(:fee_detail_selections) }
    it { should have_many(:work_order_status_changes).dependent(:destroy) }
  end
  
  # 验证测试
  describe "validations" do
    it { should validate_presence_of(:reimbursement_id) }
    it { should validate_presence_of(:type) }
    it { should validate_presence_of(:status) }
  end
  
  # 回调测试
  describe "callbacks" do
    let(:work_order) { build(:express_receipt_work_order) }
    
    it "records status change after update" do
      work_order.save!
      expect {
        work_order.update(status: 'completed') # 虽然已经是 completed，但为了测试
      }.to change(WorkOrderStatusChange, :count).by(1)
    end
  end
end
```

创建 `spec/models/express_receipt_work_order_spec.rb` 文件：

```ruby
# spec/models/express_receipt_work_order_spec.rb
require 'rails_helper'

RSpec.describe ExpressReceiptWorkOrder, type: :model do
  # 验证测试
  describe "validations" do
    it { should validate_presence_of(:tracking_number) }
    it { should validate_inclusion_of(:status).in_array(['completed']) }
  end
  
  # 业务方法测试
  describe "#mark_reimbursement_as_received" do
    let(:reimbursement) { create(:reimbursement) }
    let(:express_receipt_work_order) { 
      create(:express_receipt_work_order, 
             reimbursement: reimbursement, 
             received_at: Time.current - 1.day) 
    }
    
    it "calls mark_as_received on the associated reimbursement" do
      expect(reimbursement).to receive(:mark_as_received).with(express_receipt_work_order.received_at)
      express_receipt_work_order.mark_reimbursement_as_received
    end
    
    it "updates the reimbursement receipt_status" do
      express_receipt_work_order.mark_reimbursement_as_received
      reimbursement.reload
      expect(reimbursement.receipt_status).to eq('received')
    end
  end
  
  # 继承测试
  describe "inheritance" do
    it "is a subclass of WorkOrder" do
      expect(ExpressReceiptWorkOrder.superclass).to eq(WorkOrder)
    end
    
    it "uses the correct STI type" do
      express_receipt_work_order = create(:express_receipt_work_order)
      expect(express_receipt_work_order.type).to eq('ExpressReceiptWorkOrder')
      expect(WorkOrder.find(express_receipt_work_order.id)).to be_a(ExpressReceiptWorkOrder)
    end
  end
end
```

## 验证方法

1. 运行单元测试：
   ```bash
   rspec spec/models/work_order_spec.rb
   rspec spec/models/express_receipt_work_order_spec.rb
   ```

2. 在 Rails 控制台中手动测试模型（仅供人工验证，不要在自动化流程中执行）：
   ```ruby
   # 以下命令仅供人工在 Rails 控制台中验证，不要在自动化流程中执行
   rails console
   
   # 创建报销单
   reimbursement = Reimbursement.create!(invoice_number: "R202501001", status: "pending", is_electronic: false)
   
   # 创建快递收单工单
   work_order = ExpressReceiptWorkOrder.new(
     reimbursement: reimbursement,
     status: "completed",
     tracking_number: "SF1001",
     received_at: Time.current,
     courier_name: "顺丰"
   )
   work_order.valid? # 应返回 true
   work_order.save!
   
   # 验证状态变更记录
   work_order.work_order_status_changes.count # 应返回 1
   
   # 验证报销单状态更新
   work_order.mark_reimbursement_as_received
   reimbursement.reload.receipt_status # 应返回 "received"
   ```

## 相关文件

- `app/models/current.rb` - 当前用户上下文
- `app/models/work_order.rb` - 工单基类
- `app/models/express_receipt_work_order.rb` - 快递收单工单子类
- `spec/factories/work_orders.rb` - 测试工厂
- `spec/models/work_order_spec.rb` - 基类单元测试
- `spec/models/express_receipt_work_order_spec.rb` - 子类单元测试

## 注意事项

1. 确保 STI 继承关系正确设置，特别是 `type` 字段
2. 确保验证规则正确设置，特别是 `status` 的限制
3. 确保回调正确实现，特别是状态变更记录
4. 确保业务方法正确实现，特别是 `mark_reimbursement_as_received`
5. 确保测试覆盖所有关键功能和边缘情况
6. 确保 ActiveAdmin 配置正确，以便在管理界面中使用模型
7. 注意 `Current` 类的使用，确保在控制器中正确设置 `Current.admin_user`