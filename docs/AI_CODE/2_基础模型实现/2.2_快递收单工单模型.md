# 快递收单工单模型实现

## 任务描述

实现快递收单工单（ExpressReceiptWorkOrder）模型，作为工单系统的核心工单类型之一。快递收单工单负责处理快递收单流程，完成后创建审核工单。

## 输入和依赖

- 数据库迁移脚本（已创建的快递收单工单表）
- 报销单模型（Reimbursement）
- 模型实现设计文档 (`docs/refactoring/03_model_implementation.md`)

## 期望输出

完整的快递收单工单模型实现，包括：
- 模型属性和验证
- 与报销单的关联关系
- 状态机实现
- 状态变更记录功能
- 完成后创建审核工单的功能
- ActiveAdmin 配置

## 详细实现步骤

### 1. 创建快递收单工单模型

创建 `app/models/express_receipt_work_order.rb` 文件：

```ruby
class ExpressReceiptWorkOrder < ApplicationRecord
  # 关联
  belongs_to :reimbursement
  has_one :audit_work_order
  has_many :work_order_status_changes, as: :work_order, dependent: :destroy

  # 验证
  validates :status, presence: true
  validates :tracking_number, presence: true
  validates :reimbursement_id, presence: true

  # 回调
  after_save :record_status_change, if: :saved_change_to_status?

  # 状态机
  state_machine :status, initial: :received do
    # 定义状态
    state :received, :processed, :completed

    # 定义事件
    event :process do
      transition received: :processed
    end

    event :complete do
      transition processed: :completed
      after do
        create_audit_work_order
      end
    end

    # 状态转换前的回调
    before_transition any => any do |work_order, transition|
      # 可以在这里添加额外的验证逻辑
    end
  end

  # 方法
  def create_audit_work_order
    AuditWorkOrder.create!(
      reimbursement: reimbursement,
      express_receipt_work_order: self,
      status: 'pending',
      created_by: created_by
    )
  end

  # 获取状态变更历史
  def status_changes
    work_order_status_changes.order(changed_at: :desc)
  end

  private

  # 记录状态变更
  def record_status_change
    if saved_change_to_status?
      old_status, new_status = saved_change_to_status
      work_order_status_changes.create(
        work_order_type: 'express_receipt',
        from_status: old_status,
        to_status: new_status,
        changed_at: Time.current,
        changed_by: Current.admin_user&.id
      )
    end
  end

  # ActiveAdmin配置
  def self.ransackable_attributes(auth_object = nil)
    %w[id reimbursement_id status tracking_number received_at courier_name created_by created_at updated_at]
  end

  def self.ransackable_associations(auth_object = nil)
    %w[reimbursement audit_work_order work_order_status_changes]
  end
end
```

### 2. 创建快递收单工单工厂

创建 `spec/factories/express_receipt_work_orders.rb` 文件：

```ruby
FactoryBot.define do
  factory :express_receipt_work_order do
    association :reimbursement
    status { 'received' }
    sequence(:tracking_number) { |n| "SF#{Time.current.strftime('%Y%m%d')}#{n.to_s.rjust(3, '0')}" }
    received_at { Time.current }
    courier_name { "顺丰" }
    created_by { 1 }

    trait :processed do
      status { 'processed' }
    end

    trait :completed do
      status { 'completed' }
    end
  end
end
```

### 3. 创建快递收单工单模型测试

创建 `spec/models/express_receipt_work_order_spec.rb` 文件：

```ruby
require 'rails_helper'

RSpec.describe ExpressReceiptWorkOrder, type: :model do
  describe "validations" do
    it { should validate_presence_of(:status) }
    it { should validate_presence_of(:tracking_number) }
    it { should validate_presence_of(:reimbursement_id) }
  end

  describe "associations" do
    it { should belong_to(:reimbursement) }
    it { should have_one(:audit_work_order) }
    it { should have_many(:work_order_status_changes).dependent(:destroy) }
  end

  describe "state machine" do
    let(:work_order) { create(:express_receipt_work_order) }

    it "has initial state of received" do
      expect(work_order.status).to eq('received')
    end

    context "when processing" do
      it "can transition from received to processed" do
        expect(work_order).to be_received
        expect(work_order.process).to be_truthy
        expect(work_order).to be_processed
      end

      it "cannot transition from processed to received" do
        work_order.update(status: 'processed')
        expect(work_order).not_to be_received
        expect(work_order).not_to receive(:process)
      end
    end

    context "when completing" do
      before do
        work_order.update(status: 'processed')
      end

      it "can transition from processed to completed" do
        expect(work_order).to be_processed
        expect(work_order.complete).to be_truthy
        expect(work_order).to be_completed
      end

      it "creates an audit work order after completion" do
        expect {
          work_order.complete
        }.to change(AuditWorkOrder, :count).by(1)

        audit_work_order = AuditWorkOrder.last
        expect(audit_work_order.reimbursement_id).to eq(work_order.reimbursement_id)
        expect(audit_work_order.express_receipt_work_order_id).to eq(work_order.id)
        expect(audit_work_order.status).to eq('pending')
      end

      it "cannot transition from completed to processed" do
        work_order.update(status: 'completed')
        expect(work_order).not_to be_processed
        expect(work_order).not_to receive(:complete)
      end
    end
  end

  describe "status change recording" do
    let(:work_order) { create(:express_receipt_work_order) }

    it "records status change when status changes" do
      expect {
        work_order.process
      }.to change(WorkOrderStatusChange, :count).by(1)

      status_change = WorkOrderStatusChange.last
      expect(status_change.work_order_type).to eq('express_receipt')
      expect(status_change.work_order_id).to eq(work_order.id)
      expect(status_change.from_status).to eq('received')
      expect(status_change.to_status).to eq('processed')
    end

    it "does not record status change when status does not change" do
      expect {
        work_order.update(tracking_number: 'SF123456789')
      }.not_to change(WorkOrderStatusChange, :count)
    end
  end

  describe "#status_changes" do
    let(:work_order) { create(:express_receipt_work_order) }

    before do
      # Create some status changes
      work_order.process
      work_order.complete
    end

    it "returns status changes in descending order by changed_at" do
      status_changes = work_order.status_changes
      expect(status_changes.count).to eq(2)
      expect(status_changes.first.to_status).to eq('completed')
      expect(status_changes.last.to_status).to eq('processed')
    end
  end
end
```

### 4. 创建 ActiveAdmin 资源

创建 `app/admin/express_receipt_work_orders.rb` 文件（如果尚未创建）：

```ruby
ActiveAdmin.register ExpressReceiptWorkOrder do
  # 权限控制
  permit_params :reimbursement_id, :status, :tracking_number, :received_at, :courier_name, :created_by

  # 菜单设置
  menu priority: 2, label: "快递收单工单"

  # 过滤器
  filter :reimbursement_invoice_number, as: :string, label: '报销单号'
  filter :tracking_number
  filter :status, as: :select, collection: ExpressReceiptWorkOrder.state_machines[:status].states.map(&:name)
  filter :received_at
  filter :created_at

  # 批量操作
  batch_action :process, if: proc { params[:scope] == 'received' || params[:q].blank? } do |ids|
    batch_action_collection.find(ids).each do |work_order|
      begin
        work_order.process
      rescue StateMachines::InvalidTransition => e
        Rails.logger.warn "批量处理快递收单工单 ##{work_order.id} 失败: #{e.message}"
      end
    end
    redirect_to collection_path, notice: "已尝试将选中的工单标记为已处理"
  end

  batch_action :complete, if: proc { params[:scope] == 'processed' || params[:q].blank? } do |ids|
    batch_action_collection.find(ids).each do |work_order|
      begin
        work_order.complete
      rescue StateMachines::InvalidTransition => e
        Rails.logger.warn "批量完成快递收单工单 ##{work_order.id} 失败: #{e.message}"
      end
    end
    redirect_to collection_path, notice: "已尝试将选中的工单标记为已完成"
  end

  # 自定义操作
  action_item :process, only: :show, if: proc { resource.status == 'received' } do
    link_to "处理", process_admin_express_receipt_work_order_path(resource), method: :put
  end

  action_item :complete, only: :show, if: proc { resource.status == 'processed' } do
    link_to "完成", complete_admin_express_receipt_work_order_path(resource), method: :put
  end

  # 自定义页面
  member_action :process, method: :put do
    begin
      resource.process
      redirect_to admin_express_receipt_work_order_path(resource), notice: "工单已处理"
    rescue StateMachines::InvalidTransition => e
      redirect_to admin_express_receipt_work_order_path(resource), alert: "状态转换失败: #{e.message}"
    end
  end

  member_action :complete, method: :put do
    begin
      resource.complete
      redirect_to admin_express_receipt_work_order_path(resource), notice: "工单已完成，并已创建审核工单"
    rescue StateMachines::InvalidTransition => e
      redirect_to admin_express_receipt_work_order_path(resource), alert: "状态转换失败: #{e.message}"
    end
  end

  # 列表页
  index do
    selectable_column
    id_column
    column :reimbursement do |work_order|
      link_to work_order.reimbursement.invoice_number, admin_reimbursement_path(work_order.reimbursement)
    end
    column :tracking_number
    column :status do |work_order|
      status_tag work_order.status
    end
    column :received_at
    column :courier_name
    column :created_at
    actions
  end

  # 详情页
  show do
    attributes_table do
      row :id
      row :reimbursement do |work_order|
        link_to work_order.reimbursement.invoice_number, admin_reimbursement_path(work_order.reimbursement)
      end
      row :tracking_number
      row :status do |work_order|
        status_tag work_order.status
      end
      row :received_at
      row :courier_name
      row :created_by
      row :created_at
      row :updated_at
    end

    panel "状态变更历史" do
      table_for resource.status_changes do
        column :from_status
        column :to_status
        column :changed_at
        column :changed_by do |change|
          AdminUser.find_by(id: change.changed_by)&.email
        end
      end
    end

    panel "关联的审核工单" do
      if resource.audit_work_order.present?
        attributes_table_for resource.audit_work_order do
          row :id do |audit_wo|
            link_to audit_wo.id, admin_audit_work_order_path(audit_wo)
          end
          row :status do |audit_wo|
            status_tag audit_wo.status
          end
          row :created_at
        end
      else
        para "暂无关联的审核工单"
      end
    end
  end

  # 表单
  form do |f|
    f.inputs "快递收单工单信息" do
      f.input :reimbursement_id, as: :select, collection: Reimbursement.all.map { |r| [r.invoice_number, r.id] }
      f.input :status, as: :select, collection: ExpressReceiptWorkOrder.state_machines[:status].states.map(&:name)
      f.input :tracking_number
      f.input :received_at, as: :datepicker
      f.input :courier_name
      f.input :created_by, input_html: { value: current_admin_user.id }, as: :hidden
    end
    f.actions
  end
end
```

## 测试验证方法

1. 运行 `rspec spec/models/express_receipt_work_order_spec.rb` 确保所有测试通过
2. 在 Rails 控制台中测试模型功能：

```ruby
# 创建报销单
reimbursement = Reimbursement.create!(
  invoice_number: "R20250101001",
  document_name: "测试报销单",
  applicant: "张三",
  applicant_id: "EMP001",
  company: "测试公司",
  department: "测试部门",
  amount: 1000.00
)

# 创建快递收单工单
work_order = ExpressReceiptWorkOrder.create!(
  reimbursement: reimbursement,
  status: 'received',
  tracking_number: 'SF123456789',
  received_at: Time.current,
  courier_name: '顺丰',
  created_by: 1
)

# 测试状态转换
puts "初始状态: #{work_order.status}"
work_order.process
puts "处理后状态: #{work_order.status}"
work_order.complete
puts "完成后状态: #{work_order.status}"

# 检查是否创建了审核工单
audit_work_order = work_order.audit_work_order
puts "审核工单ID: #{audit_work_order.id}, 状态: #{audit_work_order.status}"

# 检查状态变更记录
status_changes = work_order.status_changes
puts "状态变更记录数: #{status_changes.count}"
status_changes.each do |change|
  puts "从 #{change.from_status} 到 #{change.to_status} 于 #{change.changed_at}"
end
```

3. 启动 Rails 服务器，访问 ActiveAdmin 界面，测试快递收单工单管理功能

## 注意事项

1. 确保状态机正确实现，特别是状态转换和回调函数
2. 确保状态变更记录功能正确实现
3. 确保完成后创建审核工单的功能正确实现
4. 确保与报销单的关联关系正确设置
5. 确保 ActiveAdmin 配置正确，特别是状态转换操作
6. 注意使用 `state_machines` gem 而不是 AASM，确保语法正确
7. 确保测试覆盖所有关键功能，特别是状态转换和回调函数